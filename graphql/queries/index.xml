<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Queries on</title><link>/graphql/queries/</link><description>Recent content in Queries on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/graphql/queries/index.xml" rel="self" type="application/rss+xml"/><item><title>GraphQL Queries Overview</title><link>/graphql/queries/queries-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/queries-overview/</guid><description>This guide explains how to use GraphQL queries to fetch data from Dgraph.
Dgraph automatically generates GraphQL queries for each type that you define in your schema. There are three types of queries generated for each type.
Example schema:
type Post { id: ID! title: String! @search text: String score: Float @search completed: Boolean @search datePublished: DateTime @search(by: [year]) author: Author! } type Author { id: ID! name: String! @search posts: [Post!</description></item><item><title>Search and Filtering</title><link>/graphql/queries/search-filtering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/search-filtering/</guid><description>Queries generated for a GraphQL type allow you to generate a single list of objects for a type.
Get a single object Fetch the title, text and datePublished for a post with id 0x1.
query { getPost(id: &amp;#34;0x1&amp;#34;) { title text datePublished } } Fetching nested linked objects, while using get queries is also easy. For example, this is how you would fetch the authors for a post and their friends.</description></item><item><title>Aggregate Queries</title><link>/graphql/queries/aggregate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/aggregate/</guid><description>Dgraph automatically generates aggregate queries for GraphQL schemas. Aggregate queries fetch aggregate data, including the following:
Count queries that let you count fields satisfying certain criteria specified using a filter. Advanced aggregate queries that let you calculate the maximum, minimum, sum and average of specified fields. Aggregate queries are compatible with the @auth directive and follow the same authorization rules as the query keyword. You can also use filters with aggregate queries, as shown in some of the examples provided below.</description></item><item><title>Persistent Queries</title><link>/graphql/queries/persistent-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/persistent-queries/</guid><description>Dgraph supports Persistent Queries. When a client uses persistent queries, the client only sends the hash of a query to the server. The server has a list of known hashes and uses the associated query accordingly.
Persistent queries significantly improve the performance and the security of an application since the smaller hash signature reduces bandwidth utilization and speeds up client loading times.
Persisted Query logic The execution of Persistent Queries follows this logic:</description></item><item><title>And, Or and Not Operators in GraphQL</title><link>/graphql/queries/and-or-not/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/and-or-not/</guid><description>Every GraphQL search filter can use and, or, and not operators.
GraphQL syntax uses infix notation, so: &amp;ldquo;a and b&amp;rdquo; is a, and: { b }, &amp;ldquo;a or b or c&amp;rdquo; is a, or: { b, or: c }, and &amp;ldquo;not&amp;rdquo; is a prefix (not:).
The following example queries demonstrate the use of and, or, and not operators:
Example: &amp;ldquo;Posts that do not have &amp;ldquo;GraphQL&amp;rdquo; in the title&amp;rdquo;
queryPost(filter: { not: { title: { allofterms: &amp;#34;GraphQL&amp;#34;} } } ) { .</description></item><item><title>Cached Results</title><link>/graphql/queries/cached-results/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/cached-results/</guid><description>Cached results can be used to serve read-heavy workloads with complex queries to improve performance. When cached results are enabled for a query, the stored results are served if queried within the defined time-to-live (TTL) of the cached query.
When using cached results, Dgraph will add the appropriate HTTP headers so the caching can be done at the browser or content delivery network (CDN) level.
Note Caching refers to external caching at the browser/CDN level.</description></item><item><title>Order and Pagination in GraphQL</title><link>/graphql/queries/order-page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/order-page/</guid><description>Every type with fields whose types can be ordered (Int, Float, String, DateTime) gets ordering built into the query and any list fields of that type. Every query and list field gets pagination with first and offset and ordering with order parameter.
The order parameter is not required for pagination.
For example, find the most recent 5 posts.
queryPost(order: { desc: datePublished }, first: 5) { ... } Skip the first five recent posts and then get the next 10.</description></item><item><title>@cascade Directive</title><link>/graphql/queries/cascade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/cascade/</guid><description>The @cascade directive can be applied to fields. With the @cascade directive, nodes that donâ€™t have all fields specified in the query are removed. This can be useful in cases where some filter was applied and some nodes might not have all the listed fields.
For example, the query below only returns the authors which have both reputation and posts, where posts have text. Note that @cascade trickles down so if it&amp;rsquo;s applied at the queryAuthor level, it will automatically be applied at the posts level too.</description></item><item><title>@skip and @include Directives in GraphQL</title><link>/graphql/queries/skip-include/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/skip-include/</guid><description>@skip and @include directives can be applied to query fields. They allow you to skip or include a field based on the value of the if argument that is passed to the directive.
@skip In the query below, we fetch posts and decide whether to fetch the title for them or not based on the skipTitle GraphQL variable.
GraphQL query
query ($skipTitle: Boolean!) { queryPost { id title @skip(if: $skipTitle) text } } GraphQL variables</description></item></channel></rss>