<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mutations on</title><link>/graphql/mutations/</link><description>Recent content in Mutations on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/graphql/mutations/index.xml" rel="self" type="application/rss+xml"/><item><title>Mutations Overview</title><link>/graphql/mutations/mutations-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/mutations-overview/</guid><description>Mutations allow you to modify server-side data, and it also returns an object based on the operation performed. It can be used to insert, update, or delete data. Dgraph automatically generates GraphQL mutations for each type that you define in your schema. The mutation field returns an object type that allows you to query for nested fields. This can be useful for fetching an object&amp;rsquo;s new state after an add/update, or to get the old state of an object before a delete.</description></item><item><title>Add Mutations in GraphQL</title><link>/graphql/mutations/add/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/add/</guid><description>Add mutations allow you to add new objects of a particular type.
We use the following schema to demonstrate some examples.
Schema:
type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String! @search(by: [term, fulltext]) text: String @search(by: [fulltext, term]) datePublished: DateTime } Dgraph automatically generates input and return types in the schema for the add mutation, as shown below:</description></item><item><title>Upsert Mutations</title><link>/graphql/mutations/upsert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/upsert/</guid><description>Upsert mutations allow you to perform add or update operations based on whether a particular ID exists in the database. The IDs must be external IDs, defined using the @id directive in the schema.
For example, to demonstrate how upserts work in GraphQL, take the following schema:
Schema
type Author { id: String! @id name: String! @search(by: [hash]) posts: [Post] @hasInverse(field: author) } type Post { postID: String! @id title: String!</description></item><item><title>Update Mutations in GraphQL</title><link>/graphql/mutations/update/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/update/</guid><description>Update mutations let you update existing objects of a particular type. With update mutations, you can filter nodes and set or remove any field belonging to a type.
We use the following schema to demonstrate some examples.
Schema:
type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String! @search(by: [term, fulltext]) text: String @search(by: [fulltext, term]) datePublished: DateTime } Dgraph automatically generates input and return types in the schema for the update mutation.</description></item><item><title>Delete Mutations in GraphQL</title><link>/graphql/mutations/delete/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/delete/</guid><description>Delete Mutations allow you to delete objects of a particular type.
We use the following schema to demonstrate some examples.
Schema:
type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String! @search(by: [term, fulltext]) text: String @search(by: [fulltext, term]) datePublished: DateTime } Dgraph automatically generates input and return types in the schema for the delete mutation. Delete mutations take filter as an input to select specific objects and returns the state of the objects before deletion.</description></item><item><title>Deep Mutations</title><link>/graphql/mutations/deep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/deep/</guid><description>You can perform deep mutations at multiple levels. Deep mutations do not alter linked objects, but they can add deeply-nested new objects or link to existing objects. To update an existing nested object, use the update mutation for its type.
We use the following schema to demonstrate some examples.
Schema: type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String!</description></item></channel></rss>