<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Custom Resolvers on</title><link>/graphql/custom/</link><description>Recent content in Custom Resolvers on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/graphql/custom/index.xml" rel="self" type="application/rss+xml"/><item><title>Custom Resolvers Overview</title><link>/graphql/custom/custom-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/custom-overview/</guid><description>Dgraph creates a GraphQL API from nothing more than GraphQL types. That&amp;rsquo;s great, and gets you moving fast from an idea to a running app. However, at some point, as your app develops, you might want to customize the behavior of your schema.
In Dgraph, you do that with code (in any language you like) that implements custom resolvers.
Dgraph doesn&amp;rsquo;t execute your custom logic itself. It makes external HTTP requests.</description></item><item><title>The @custom Directive</title><link>/graphql/custom/directive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/directive/</guid><description>The @custom directive is used to define custom queries, mutations and fields.
In all cases, the result type (of the query, mutation or field) can be either:
a type that&amp;rsquo;s stored in Dgraph (that&amp;rsquo;s any type you&amp;rsquo;ve defined in your schema), or a type that&amp;rsquo;s not stored in Dgraph and is marked with the @remote directive. Because the result types can be local or remote, you can call other HTTP endpoints, call remote GraphQL, or even call back to your Dgraph instance to add extra logic on top of Dgraph&amp;rsquo;s graph search or mutations.</description></item><item><title>Custom Queries</title><link>/graphql/custom/query/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/query/</guid><description>Let&amp;rsquo;s say we want to integrate our app with an existing external REST API. There&amp;rsquo;s a few things we need to know:
The URL of the API, the path and any parameters required The shape of the resulting JSON data The method (GET, POST, etc.), and What authorization we need to pass to the external endpoint The custom query can take any number of scalar arguments and use those to construct the path, parameters and body (we&amp;rsquo;ll see an example of that in the custom mutation section) of the request that gets sent to the remote endpoint.</description></item><item><title>Custom Mutations</title><link>/graphql/custom/mutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/mutation/</guid><description>With custom mutations, you can use custom logic to define values for one or more fields in a mutation.
Let&amp;rsquo;s say we have an application about authors and posts. Logged in authors can add posts, but we want to do some input validation and add extra value when a post is added. The key types might be as follows.
type Author { ... } type Post { id: ID: title: String text: String datePublished: DateTime author: Author .</description></item><item><title>Custom Fields</title><link>/graphql/custom/field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/field/</guid><description>Custom fields allow you to extend your types with custom logic as well as make joins between your local data and remote data.
Let&amp;rsquo;s say we are building an app for managing projects. Users will login with their GitHub id and we want to connect some data about their work stored in Dgraph with say their GitHub profile, issues, etc.
Our first version of our users might start out with just their GitHub username and some data about what projects they are working on.</description></item><item><title>Custom DQL</title><link>/graphql/custom/dql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/dql/</guid><description>Dgraph Query Language (DQL - formerly GraphQL+-) is rapidly evolving, and now includes support for custom logic. You can specify the DQL (aka GraphQL+-) query you want to execute while running a custom GraphQL query, and Dgraph&amp;rsquo;s GraphQL API will execute that for you.
DQL lets you build custom logic that goes beyond what is possible with the current GraphQL CRUD API.
Tip Since v21.03, you can also subscribe to custom DQL queries.</description></item></channel></rss>