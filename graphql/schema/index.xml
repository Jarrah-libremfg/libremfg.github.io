<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Schema on</title><link>/graphql/schema/</link><description>Recent content in Schema on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/graphql/schema/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview</title><link>/graphql/schema/schema-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/schema-overview/</guid><description>This section describes all the things you can put in your input GraphQL schema, and what gets generated from that.
The process for serving GraphQL with Dgraph is to add a set of GraphQL type definitions using the /admin endpoint. Dgraph takes those definitions, generates queries and mutations, and serves the generated GraphQL schema.
The input schema may contain interfaces, types and enums that follow the usual GraphQL syntax and validation rules.</description></item><item><title>Reserved Names in GraphQL</title><link>/graphql/schema/reserved/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/reserved/</guid><description>The following names are reserved and can&amp;rsquo;t be used to define any other identifiers:
Int Float Boolean String DateTime ID uid Subscription as (case-insensitive) Query Mutation Point PointList Polygon MultiPolygon Aggregate (as a suffix of any identifier name) For each type, Dgraph generates a number of GraphQL types needed to operate the GraphQL API, these generated type names also can&amp;rsquo;t be present in the input schema. For example, for a type Author, Dgraph generates:</description></item><item><title>Schema Migration</title><link>/graphql/schema/migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/migration/</guid><description>In every app&amp;rsquo;s development lifecycle, there&amp;rsquo;s a point where the underlying schema doesn&amp;rsquo;t fit the requirements and must be changed for good. That requires a migration for both schema and the underlying data. This article will guide you through common migration scenarios you can encounter with Dgraph and help you avoid any pitfalls around them.
These are the most common scenarios that can occur:
Renaming a type Renaming a field Changing a field&amp;rsquo;s type Adding @id to an existing field Note As long as you can avoid migration, avoid it.</description></item><item><title>Types in GraphQL</title><link>/graphql/schema/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/types/</guid><description>This page describes how you can use GraphQL types to set up a GraphQL schema for Dgraph database.
Scalars Dgraph&amp;rsquo;s GraphQL implementation comes with the standard GraphQL scalar types: Int, Float, String, Boolean and ID. There&amp;rsquo;s also an Int64 scalar, and a DateTime scalar type that is represented as a string in RFC3339 format.
Scalar types, including Int, Int64, Float, String and DateTime; can be used in lists. Lists behave like an unordered set in Dgraph.</description></item><item><title>IDs in GraphQL</title><link>/graphql/schema/ids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/ids/</guid><description>Dgraph provides two types of built-in identifiers: the ID scalar type and the @id directive.
The ID scalar type is used when you don&amp;rsquo;t need to set an identifier outside of Dgraph. The @id directive is used for external identifiers, such as email addresses. The ID type In Dgraph, every node has a unique 64-bit identifier that you can expose in GraphQL using the ID type. An ID is auto-generated, immutable and never reused.</description></item><item><title>Links in the GraphQL Graph</title><link>/graphql/schema/graph-links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/graph-links/</guid><description>All the data in your app forms a GraphQL data graph. That graph has nodes of particular types (the types you define in your schema) and links between the nodes to form the data graph.
Dgraph uses the types and fields in the schema to work out how to link that graph, what to accept for mutations and what shape responses should take.
Edges in that graph are directed: either pointing in one direction or two.</description></item><item><title>Search and Filtering</title><link>/graphql/schema/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/search/</guid><description>The @search directive tells Dgraph what search to build into your GraphQL API.
When a type contains an @search directive, Dgraph constructs a search input type and a query in the GraphQL Query type. For example, if the schema contains
type Post { ... } then Dgraph constructs a queryPost GraphQL query for querying posts. The @search directives in the Post type control how Dgraph builds indexes and what kinds of search it builds into queryPost.</description></item><item><title>The @generate Directive</title><link>/graphql/schema/generate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/generate/</guid><description>The @generate directive is used to specify which GraphQL APIs are generated for a given type.
Here&amp;rsquo;s the GraphQL definition of the directive
input GenerateQueryParams { get: Boolean query: Boolean password: Boolean aggregate: Boolean } input GenerateMutationParams { add: Boolean update: Boolean delete: Boolean } directive @generate( query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT | INTERFACE The corresponding APIs are generated by setting the Boolean variables inside the @generate directive to true.</description></item><item><title>Documentation and Comments</title><link>/graphql/schema/documentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/documentation/</guid><description>Schema Documentation Processed by Generated API Dgraph accepts GraphQL documentation comments (e.g. &amp;quot;&amp;quot;&amp;quot; This is a graphql comment &amp;quot;&amp;quot;&amp;quot;), which get passed through to the generated API and thus shown as documentation in GraphQL tools like GraphiQL, GraphQL Playground, Insomnia etc.
Schema Documentation Ignored by Generated API You can also add # ... comments where ever you like. These comments are not passed via the generated API and are not visible in the API docs.</description></item><item><title>Deprecation</title><link>/graphql/schema/deprecated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/deprecated/</guid><description>The @deprecated directive allows you to tag the schema definition of a field or enum value as deprecated with an optional reason.
When you use the @deprecated directive, GraphQL users can deprecate their use of the deprecated field or enum value. Most GraphQL tools and clients will pick up this notification and give you a warning if you try to use a deprecated field.
Example For example, to mark oldField in the schema as deprecated:</description></item><item><title>Dgraph Schema Fragment</title><link>/graphql/schema/dgraph-schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/dgraph-schema/</guid><description>While editing your schema, you might find it useful to include this GraphQL schema fragment. It sets up the definitions of the directives, etc. (like @search) that you&amp;rsquo;ll use in your schema. If your editor is GraphQL aware, it may give you errors if you don&amp;rsquo;t have this available and context sensitive help if you do.
Don&amp;rsquo;t include it in your input schema to Dgraph - use your editing environment to set it up as an import.</description></item></channel></rss>