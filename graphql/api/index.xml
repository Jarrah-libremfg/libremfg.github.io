<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API on</title><link>/graphql/api/</link><description>Recent content in API on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/graphql/api/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview</title><link>/graphql/api/api-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/api-overview/</guid><description>How to use the GraphQL API.
Dgraph serves spec-compliant GraphQL over HTTP to two endpoints: /graphql and /admin.
In Dgraph Cloud /graphql and /admin are served from the domain of your backend, which will be something like https://YOUR-SUBDOMAIN.REGION.aws.cloud.dgraph.io. If you are running a self-hosted Dgraph instance that will be at the alpha port and url (which defaults to http://localhost:8080 if you aren&amp;rsquo;t changing any settings).
In each case, both GET and POST requests are served.</description></item><item><title>Requests and Responses in GraphQL</title><link>/graphql/api/requests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/requests/</guid><description>In this section, we&amp;rsquo;ll cover the structure for GraphQL requests and responses, how to enable compression for them, and configuration options for extensions.
Requests GraphQL requests can be sent via HTTP POST or HTTP GET requests.
POST requests sent with the Content-Type header application/graphql must have a POST body content as a GraphQL query string. For example, the following is a valid POST body for a query:
query { getTask(id: &amp;#34;0x3&amp;#34;) { id title completed user { username name } } } POST requests sent with the Content-Type header application/json must have a POST body in the following JSON format:</description></item><item><title>GraphQL Variables</title><link>/graphql/api/variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/variables/</guid><description>Variables simplify GraphQL queries and mutations by letting you pass data separately. A GraphQL request can be split into two sections: one for the query or mutation, and another for variables.
Variables can be declared after the query or mutation and are passed like arguments to a function and begin with $.
Query Example : query post($filter: PostFilter) { queryPost(filter: $filter) { title text author { name } } } Variables: { &amp;#34;filter&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;eq&amp;#34;: &amp;#34;First Post&amp;#34; } } } Result: { &amp;#34;data&amp;#34;: { &amp;#34;queryPost&amp;#34;: [{ &amp;#34;title&amp;#34;: &amp;#34;First Post&amp;#34;, &amp;#34;text&amp;#34;: &amp;#34;Hello world!</description></item><item><title>GraphQL Fragments</title><link>/graphql/api/fragments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/fragments/</guid><description>A GraphQL fragment is a reusable unit of logic that can be shared between multiple queries and mutations. Here, we declare a postData fragment that can be used with any Post object:
fragment postData on Post { id title text author { username displayName } } The fragment has a subset of the fields from its associated type. In the above example, the Post type must declare all the fields present in the postData fragment for it be valid.</description></item><item><title>Multiple GraphQL Operations in a Request</title><link>/graphql/api/multiples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/multiples/</guid><description>GraphQL requests can contain one or more operations. Operations include query, mutation, or subscription. If a request only has one operation, then it can be unnamed like the following:
Single Operation The most basic request contains a single anonymous (unnamed) operation. Each operation can have one or more queries within in. For example, the following query has query operation running the queries &amp;ldquo;getTask&amp;rdquo; and &amp;ldquo;getUser&amp;rdquo;:
query { getTask(id: &amp;#34;0x3&amp;#34;) { id title completed } getUser(username: &amp;#34;dgraphlabs&amp;#34;) { username } } Response:</description></item><item><title>GraphQL Error Propagation</title><link>/graphql/api/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/errors/</guid><description>Before returning query and mutation results, Dgraph uses the types in the schema to apply GraphQL value completion and error handling. That is, null values for non-nullable fields, e.g. String!, cause error propagation to parent fields.
In short, the GraphQL value completion and error propagation mean the following.
Fields marked as nullable (i.e. without !) can return null in the json response. For fields marked as non-nullable (i.e. with !</description></item></channel></rss>