<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Concepts on</title><link>/design-concepts/</link><description>Recent content in Design Concepts on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Mar 2017 22:25:17 +1100</lastBuildDate><atom:link href="/design-concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>Transactions: FAQ</title><link>/design-concepts/transactions-faq/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/transactions-faq/</guid><description>Dgraph supports distributed ACID transactions through snapshot isolation.
Can we do pre-writes only on leaders? Seems like a good idea, but has bad implications. If we only do a prewrite in-memory, only on leader, then this prewrite wouldn&amp;rsquo;t make it to the Raft log, or disk; but would be considered successful.
Then zero could mark the transaction as committed; but this leader could go down, or leadership could change. In such a case, we&amp;rsquo;d end up losing the transaction altogether despite it having been considered committed.</description></item><item><title>Consistency Model</title><link>/design-concepts/consistency-model/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/consistency-model/</guid><description>[Update on Jan 15, 2020]
Dgraph supports MVCC, Read Snapshots and Distributed ACID transactions. The transactions are cluster-wide (not key-only, or any other &amp;ldquo;crippled&amp;rdquo; version of them). Transactions are lockless. They don&amp;rsquo;t block/wait on seeing pending writes by uncommitted transactions. Zero would choose to commit or abort them depending on conflicts. Transactions are based on Snapshot Isolation (not Serializable Snapshot Isolation), because conflicts are determined by writes (not reads). Dgraph hands out monotonically increasing timestamps (for transactions).</description></item><item><title>Concepts</title><link>/design-concepts/concepts/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/concepts/</guid><description>Edges Typical data format is RDF N-Quad which is:
Subject, Predicate, Object, Label, aka Entity, Attribute, Other Entity / Value, Label Both the terminologies get used interchangeably in our code. Dgraph considers edges to be directional, i.e. from Subject -&amp;gt; Object. This is the direction that the queries would be run.
Tip Dgraph can automatically generate a reverse edge. If the user wants to run queries in that direction, they would need to define the reverse edge as part of the schema.</description></item><item><title>How Dgraph Minimizes Network Calls</title><link>/design-concepts/minimizing-network-calls/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/minimizing-network-calls/</guid><description>To explain how Dgraph minimizes network calls, let&amp;rsquo;s start with an example query we should be able to run.
Find all posts liked by friends of friends of mine over the last year, written by a popular author X.
SQL/NoSQL In a distributed SQL/NoSQL database, this would require you to retrieve a lot of data.
Method 1:
Find all the friends (~ 338 friends). Find all their friends (~ 338 * 338 = 40,000 people).</description></item><item><title>RAFT</title><link>/design-concepts/raft/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/raft/</guid><description>This section aims to explain the RAFT consensus algorithm in simple terms. The idea is to give you just enough to make you understand the basic concepts, without going into explanations about why it works accurately. For a detailed explanation of RAFT, please read the original thesis paper by Diego Ongaro.
Term Each election cycle is considered a term, during which there is a single leader (just like in a democracy).</description></item></channel></rss>