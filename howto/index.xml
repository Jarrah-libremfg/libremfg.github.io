<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>How To Guides on</title><link>/howto/</link><description>Recent content in How To Guides on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Mar 2017 19:35:35 +1100</lastBuildDate><atom:link href="/howto/index.xml" rel="self" type="application/rss+xml"/><item><title>Retrieving Debug Information</title><link>/howto/retrieving-debug-information/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/retrieving-debug-information/</guid><description>Each Dgraph data node exposes profile over /debug/pprof endpoint and metrics over /debug/vars endpoint. Each Dgraph data node has it&amp;rsquo;s own profiling and metrics information. Below is a list of debugging information exposed by Dgraph and the corresponding commands to retrieve them.
Metrics Information If you are collecting these metrics from outside the Dgraph instance you need to pass --expose_trace=true flag, otherwise there metrics can be collected by connecting to the instance over localhost.</description></item><item><title>Shell Completion</title><link>/howto/completion/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/completion/</guid><description>Command-line completion is a common feature provided by shells like bash or zsh that lets you type commands in a fast and easy way. This functionality automatically fills in partially typed commands when the user press the tab key.
Completion script The command-line interpreter requires a completion script to define which completion suggestions can be displayed for a given executable.
Using the dgraph completion command you can generate a file that can be added to your shell configuration.</description></item><item><title>Using the Debug Tool</title><link>/howto/using-debug-tool/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/using-debug-tool/</guid><description>Note To debug a running Dgraph cluster, first copy the postings (&amp;ldquo;p&amp;rdquo;) directory to another location. If the Dgraph cluster is not running, then you can use the same postings directory with the debug tool.
If the “p” directory has been encrypted, then the debug tool will need to use the &amp;ndash;keyfile option. This file must contain the same key that was used to encrypt the “p” directory.
The dgraph debug tool can be used to inspect Dgraph&amp;rsquo;s posting list structure.</description></item><item><title>Using the Dgraph Sentry Integration</title><link>/howto/dgraph-sentry-integration/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/dgraph-sentry-integration/</guid><description>Sentry is a powerful service that allows applications to send arbitrary events, messages, exceptions, bread-crumbs (logs) to your sentry account. In simplest terms, it is a dial-home service but also has a rich feature set including event filtering, data scrubbing, several SDKs, custom and release tagging, as well as integration with 3rd party tools such as Slack, GitHub.
Although Sentry reporting is on by default, starting from v20.03.1 and v20.07.0, there is a configuration flag enable-sentry which can be used to completely turn off Sentry events reporting.</description></item><item><title>Using the Increment Tool</title><link>/howto/using-increment-tool/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/using-increment-tool/</guid><description>The dgraph increment tool increments a counter value transactionally. The increment tool can be used as a health check that an Alpha is able to service transactions for both queries and mutations.
Example Usage Increment the default predicate (counter.val) once. If the predicate doesn&amp;rsquo;t yet exist, then it will be created starting at counter 0.
$ dgraph increment Increment the counter predicate against the Alpha running at address --alpha (default: localhost:9080):</description></item><item><title>Giving Nodes a Type</title><link>/howto/giving-nodes-type/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/giving-nodes-type/</guid><description>It&amp;rsquo;s often useful to give the nodes in a graph types (also commonly referred to as labels or kinds). You can do so using the type system.</description></item><item><title>A Simple Login System</title><link>/howto/login-system/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/login-system/</guid><description>Note This example is based on part of the transactions in v0.9 blogpost. Error checking has been omitted for brevity. Schema is assumed to be:
// @upsert directive is important to detect conflicts. email: string @index(exact) @upsert . # @index(hash) would also work pass: password . // Create a new transaction. The deferred call to Discard // ensures that server-side resources are cleaned up. txn := client.NewTxn() defer txn.Discard(ctx) // Create and execute a query to looks up an email and checks if the password // matches.</description></item><item><title>Load Balancing Queries with NGINX</title><link>/howto/load-balancing-nginx/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/load-balancing-nginx/</guid><description>There might be times when you&amp;rsquo;ll want to set up a load balancer to accomplish goals such as increasing the utilization of your database by sending queries from the app to multiple database server replicas. You can follow these steps to get started with that.
Setting up NGINX load balancer using Docker Compose Download ZIP Download the contents of this gist&amp;rsquo;s ZIP file and extract it to a directory called graph-nginx, as follows:</description></item><item><title>Upserts</title><link>/howto/upserts/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/upserts/</guid><description>Upsert-style operations are operations where:
A node is searched for, and then Depending on if it is found or not, either: Updating some of its attributes, or Creating a new node with those attributes. The upsert has to be an atomic operation such that either a new node is created, or an existing node is modified. It&amp;rsquo;s not allowed that two concurrent upserts both create a new node.
There are many examples where upserts are useful.</description></item><item><title>Run Jepsen Tests</title><link>/howto/jepsen-tests/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/jepsen-tests/</guid><description> Clone the Jepsen repo at https://github.com/jepsen-io/jepsen. git clone git@github.com:jepsen-io/jepsen.git Run the following command to setup the instances from the repo. cd docker &amp;amp;&amp;amp; ./up.sh This should start 5 Jepsen nodes in docker containers.
Now ssh into jepsen-control container and run the tests. docker exec -it jepsen-control bash root@control:/jepsen# cd dgraph root@control:/jepsen/dgraph# lein run test -w upsert # Specify a --package-url root@control:/jepsen/dgraph# lein run test --force-download --package-url https://github.com/dgraph-io/dgraph/releases/download/nightly/dgraph-linux-amd64.tar.gz -w upsert</description></item><item><title>Lambda Webhooks Example</title><link>/howto/lambda-webhooks-example/</link><pubDate>Sun, 10 Sep 2017 22:25:17 +1100</pubDate><guid>/howto/lambda-webhooks-example/</guid><description>It is a common need to populate a &amp;ldquo;Created At&amp;rdquo; date whenever a new data is created. Using Lambda Webhooks, the population of this field can be offloaded from the clients to a Dgraph Lambda. Lambda Webhooks are special kind of lambdas that are automatically invoked whenever data belonging to a GraphQL type is added, modified, or deleted.
Steps to run this example are as follows.
The GraphQL Schema type Author @lambdaOnMutate(add: true, update: true, delete: true) { id: ID!</description></item></channel></rss>