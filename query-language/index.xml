<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DQL Query Language Reference on</title><link>/query-language/</link><description>Recent content in DQL Query Language Reference on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Mar 2017 22:25:17 +1100</lastBuildDate><atom:link href="/query-language/index.xml" rel="self" type="application/rss+xml"/><item><title>DQL Fundamentals</title><link>/query-language/graphql-fundamentals/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/graphql-fundamentals/</guid><description>Dgraph Query Language, DQL, (previously named GraphQL+-) is based on GraphQL maintained by the GraphQL Foundation. GraphQL wasn&amp;rsquo;t developed for Graph databases, but its graph-like query syntax, schema validation and subgraph shaped response make it a great language choice. We&amp;rsquo;ve modified the language to better support graph operations, adding and removing features to get the best fit for graph databases.
DQL is a work in progress. We&amp;rsquo;re adding more features and we might further simplify existing ones.</description></item><item><title>Functions with DQL</title><link>/query-language/functions/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/functions/</guid><description>Dgraph Query Language (DQL) functions allow filtering based on properties of nodes or variables. Functions can be applied in the query root or in filters.
Comparison functions (eq, ge, gt, le, lt) in the query root (aka func:) can only be applied on indexed predicates. Since v1.2, comparison functions can now be used on @filter directives even on predicates that have not been indexed. Filtering on non-indexed predicates can be slow for large datasets, as they require iterating over all of the possible values at the level where the filter is being used.</description></item><item><title>Connecting Filters</title><link>/query-language/connecting-filters/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/connecting-filters/</guid><description>Within @filter multiple functions can be used with boolean connectives.
AND, OR and NOT Connectives AND, OR and NOT join filters and can be built into arbitrarily complex filters, such as (NOT A OR B) AND (C AND NOT (D OR E)). Note that, NOT binds more tightly than AND which binds more tightly than OR.
Query Example : All Steven Spielberg movies that contain either both &amp;ldquo;indiana&amp;rdquo; and &amp;ldquo;jones&amp;rdquo; OR both &amp;ldquo;jurassic&amp;rdquo; and &amp;ldquo;park&amp;rdquo;.</description></item><item><title>Aliases</title><link>/query-language/alias/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/alias/</guid><description>Syntax Examples:
aliasName : predicate aliasName : predicate { ... } aliasName : varName as ... aliasName : count(predicate) aliasName : max(val(varName)) An alias provides an alternate name in results. Predicates, variables and aggregates can be aliased by prefixing with the alias name and :. Aliases do not have to be different to the original predicate name, but, within a block, an alias must be distinct from predicate names and other aliases returned in the same block.</description></item><item><title>Pagination in DQL</title><link>/query-language/pagination/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/pagination/</guid><description>Pagination allows returning only a portion, rather than the whole, result set. This can be useful for top-k style queries as well as to reduce the size of the result set for client side processing or to allow paged access to results.
Pagination is often used with sorting.
Note Without a sort order specified, the results are sorted by uid, which is assigned randomly. So the ordering, while deterministic, might not be what you expected.</description></item><item><title>Count in DQL</title><link>/query-language/count/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/count/</guid><description>Syntax Examples:
count(predicate) count(uid) The form count(predicate) counts how many predicate edges lead out of a node.
The form count(uid) counts the number of UIDs matched in the enclosing block.
Query Example: The number of films acted in by each actor with Orlando in their name.
Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { me(func: allofterms(name@en, &amp;#34;Orlando&amp;#34;)) @filter(has(actor.film)) { name@en count(actor.film) } } { me(func: allofterms(name@en, &amp;#34;Orlando&amp;#34;)) @filter(has(actor.</description></item><item><title>Sorting</title><link>/query-language/sorting/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/sorting/</guid><description>Syntax Examples:
q(func: ..., orderasc: predicate) q(func: ..., orderdesc: val(varName)) predicate (orderdesc: predicate) { ... } predicate @filter(...) (orderasc: N) { ... } q(func: ..., orderasc: predicate1, orderdesc: predicate2) Sortable Types: int, float, String, dateTime, default
Results can be sorted in ascending order (orderasc) or descending order (orderdesc) by a predicate or variable.
For sorting on predicates with sortable indices, Dgraph sorts on the values and with the index in parallel and returns whichever result is computed first.</description></item><item><title>Multiple Query Blocks with DQL</title><link>/query-language/multiple-query-blocks/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/multiple-query-blocks/</guid><description>Inside a single query, multiple query blocks are allowed, and each block can have a name. Multiple query blocks are executed in parallel, and they don&amp;rsquo;t need to be related in any way.
Query Example: &amp;ldquo;All of Angelina Jolie&amp;rsquo;s films, with genres, and Peter Jackson&amp;rsquo;s films since 2008&amp;rdquo;
Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { AngelinaInfo(func:allofterms(name@en, &amp;#34;angelina jolie&amp;#34;)) { name@en actor.film { performance.film { genre { name@en } } } } DirectorInfo(func: eq(name@en, &amp;#34;Peter Jackson&amp;#34;)) { name@en director.</description></item><item><title>Query Variables in DQL</title><link>/query-language/query-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/query-variables/</guid><description>Syntax Examples:
varName as q(func: ...) { ... } varName as var(func: ...) { ... } varName as predicate { ... } varName as predicate @filter(...) { ... } Types : uid
Nodes (UIDs) matched at one place in a query can be stored in a variable and used elsewhere. Query variables can be used in other query blocks or in a child node of the defining block.
Query variables do not affect the semantics of the query at the point of definition.</description></item><item><title>Value Variables in DQL</title><link>/query-language/value-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/value-variables/</guid><description>Value variables store scalar values in DQL. Value variables are a map from the UIDs of the enclosing block to the corresponding values.
The following are examples of value variables:
varName as scalarPredicate varName as count(predicate) varName as avg(...) varName as math(...) These variables map to the following types: int, float, String, dateTime, default, geo, bool
It only makes sense to use the values from a value variable in a context that matches the same UIDs - if used in a block matching different UIDs the value variable is undefined.</description></item><item><title>Aggregation in DQL</title><link>/query-language/aggregation/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/aggregation/</guid><description>Syntax Example: AG(val(varName))
For AG replaced with
min : select the minimum value in the value variable varName max : select the maximum value sum : sum all values in value variable varName avg : calculate the average of values in varName Schema Types:
Aggregation Schema Types min / max int, float, string, dateTime, default sum / avg int, float Aggregation can only be applied to value variables. An index is not required (the values have already been found and stored in the value variable mapping).</description></item><item><title>Math on Value Variables</title><link>/query-language/math-on-value-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/math-on-value-variables/</guid><description>Value variables can be combined using mathematical functions. For example, this could be used to associate a score which is then used to order or perform other operations, such as might be used in building news feeds, simple recommendation systems, and so on.
Math statements must be enclosed within math( &amp;lt;exp&amp;gt; ) and must be stored to a value variable.
The supported operators are as follows:
Operators Types accepted What it does + - * / % int, float performs the corresponding operation min max All types except geo, bool (binary functions) selects the min/max value among the two &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == !</description></item><item><title>GroupBy</title><link>/query-language/groupby/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/groupby/</guid><description>Syntax Examples:
q(func: ...) @groupby(predicate) { min(...) } predicate @groupby(pred) { count(uid) } A groupby query aggregates query results given a set of properties on which to group elements. For example, a query containing the block friend @groupby(age) { count(uid) }, finds all nodes reachable along the friend edge, partitions these into groups based on age, then counts how many nodes are in each group. The returned result is the grouped edges and the aggregations.</description></item><item><title>Expand Predicates in DQL</title><link>/query-language/expand-predicates/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/expand-predicates/</guid><description>The expand() function can be used to expand the predicates out of a node. To use expand(), the type system is required. Refer to the section on the type system to check how to set the types nodes. The rest of this section assumes familiarity with that section.
There are two ways to use the expand function:
1. Expand predicates by type Types can be passed to expand() to expand all the predicates of the specified type.</description></item><item><title>Cascade Directive</title><link>/query-language/cascade-directive/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/cascade-directive/</guid><description>With the @cascade directive, nodes that don&amp;rsquo;t have all predicates specified in the query are removed. This can be useful in cases where some filter was applied or if nodes might not have all listed predicates.
Query Example: Harry Potter movies, with each actor and characters played. With @cascade, any character not played by an actor called Warwick is removed, as is any Harry Potter movie without any actors called Warwick.</description></item><item><title>@normalize Directive</title><link>/query-language/normalize-directive/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/normalize-directive/</guid><description>With the @normalize directive, only aliased predicates are returned and the result is flattened to remove nesting.
Query Example: Film name, country and first two actors (by UID order) of every Steven Spielberg movie, without initial_release_date because no alias is given and flattened by @normalize Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { director(func:allofterms(name@en, &amp;#34;steven spielberg&amp;#34;)) @normalize { director: name@en director.film { film: name@en initial_release_date starring(first: 2) { performance.</description></item><item><title>@ignorereflex Directive</title><link>/query-language/ignorereflex-directive/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/ignorereflex-directive/</guid><description>The @ignorereflex directive forces the removal of child nodes that are reachable from themselves as a parent, through any path in the query result
Query Example: All the co-actors of Rutger Hauer. Without @ignorereflex, the result would also include Rutger Hauer for every movie.
Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { coactors(func: eq(name@en, &amp;#34;Rutger Hauer&amp;#34;)) @ignorereflex { actor.film { performance.film { starring { performance.actor { name@en } } } } } } { coactors(func: eq(name@en, &amp;#34;Rutger Hauer&amp;#34;)) @ignorereflex { actor.</description></item><item><title>Debug</title><link>/query-language/debug/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/debug/</guid><description>For the purposes of debugging, you can attach a query parameter debug=true to a query. Attaching this parameter lets you retrieve the uid attribute for all the entities along with the server_latency and start_ts information under the extensions key of the response.
parsing_ns: Latency in nanoseconds to parse the query. processing_ns: Latency in nanoseconds to process the query. encoding_ns: Latency in nanoseconds to encode the JSON response. start_ts: The logical start timestamp of the transaction.</description></item><item><title>Schemas in DQL</title><link>/query-language/schema/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/schema/</guid><description>For each predicate, the Dgraph Query Language (DQL) schema specifies the target&amp;rsquo;s type. If a predicate p has type T, then for all subject-predicate-object triples s p o the object o is of schema type T.
On mutations, scalar types are checked and an error thrown if the value cannot be converted to the schema type.
On query, value results are returned according to the schema type of the predicate.</description></item><item><title>DQL Type System</title><link>/query-language/type-system/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/type-system/</guid><description>Dgraph supports a type system that can be used to categorize nodes and query them based on their type. The type system is also used during expand queries.
Type definition Types are defined using a GraphQL-like syntax. For example:
type Student { name dob home_address year friends } Note You can&amp;rsquo;t define type names starting with dgraph., it is reserved as the namespace for Dgraph&amp;rsquo;s internal types/predicates. For example, defining dgraph.</description></item><item><title>Facets and Edge Attributes in DQL</title><link>/query-language/facets/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/facets/</guid><description>Dgraph supports facets &amp;mdash; key value pairs on edges &amp;mdash; as an extension to RDF triples. That is, facets add properties to edges, rather than to nodes. For example, a friend edge between two nodes may have a Boolean property of close friendship. Facets can also be used as weights for edges.
Though you may find yourself leaning towards facets many times, they should not be misused. It wouldn&amp;rsquo;t be correct modeling to give the friend edge a facet date_of_birth.</description></item><item><title>Shortest Path Queries</title><link>/query-language/kshortest-path-quries/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/kshortest-path-quries/</guid><description>The shortest path between a source (from) node and destination (to) node can be found using the keyword shortest for the query block name. It requires the source node UID, destination node UID and the predicates (at least one) that have to be considered for traversal. A shortest query block returns the shortest path under _path_ in the query response. The path can also be stored in a variable which is used in other query blocks.</description></item><item><title>Recurse Query</title><link>/query-language/recurse-query/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/recurse-query/</guid><description>Recurse queries let you traverse a set of predicates (with filter, facets, etc.) until we reach all leaf nodes or we reach the maximum depth which is specified by the depth parameter.
To get 10 movies from a genre that has more than 30000 films and then get two actors for those movies we&amp;rsquo;d do something as follows: Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { me(func: gt(count(~genre), 30000), first: 1) @recurse(depth: 5, loop: true) { name@en ~genre (first:10) @filter(gt(count(starring), 2)) starring (first: 2) performance.</description></item><item><title>Fragments</title><link>/query-language/fragments/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/fragments/</guid><description>The fragment keyword lets you define new fragments that can be referenced in a query, per the Fragments section of the GraphQL specification. Fragments allow for the reuse of common repeated selections of fields, reducing duplicated text in the DQL documents. Fragments can be nested inside fragments, but no cycles are allowed in such cases. For example:
curl -H &amp;#34;Content-Type: application/dql&amp;#34; localhost:8080/query -XPOST -d $&amp;#39; query { debug(func: uid(1)) { name@en .</description></item><item><title>GraphQL Variables</title><link>/query-language/graphql-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/graphql-variables/</guid><description>Syntax Examples (using default values):
query title($name: string = &amp;quot;Bauman&amp;quot;) { ... } query title($age: int = &amp;quot;95&amp;quot;) { ... } query title($uids: string = &amp;quot;0x1&amp;quot;) { ... } query title($uids: string = &amp;quot;[0x1, 0x2, 0x3]&amp;quot;) { ... }. The value of the variable is a quoted array. Variables can be defined and used in queries which helps in query reuse and avoids costly string building in clients at runtime by passing a separate variable map.</description></item><item><title>Indexing with Custom Tokenizers</title><link>/query-language/indexing-custom-tokenizers/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/indexing-custom-tokenizers/</guid><description>Dgraph comes with a large toolkit of builtin indexes, but sometimes for niche use cases they&amp;rsquo;re not always enough.
Dgraph allows you to implement custom tokenizers via a plugin system in order to fill the gaps.
Caveats The plugin system uses Go&amp;rsquo;s pkg/plugin. This brings some restrictions to how plugins can be used.
Plugins must be written in Go.
As of Go 1.9, pkg/plugin only works on Linux. Therefore, plugins will only work on Dgraph instances deployed in a Linux environment.</description></item></channel></rss>