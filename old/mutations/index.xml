<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mutations in DQL on</title><link>/old/mutations/</link><description>Recent content in Mutations in DQL on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Mar 2017 19:35:35 +1100</lastBuildDate><atom:link href="/old/mutations/index.xml" rel="self" type="application/rss+xml"/><item><title>Triples in DQL</title><link>/old/mutations/triples/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/triples/</guid><description>A mutation that adds triples is done with the set keyword.
{ set { # triples in here } } The input language is triples in the W3C standard RDF N-Quad format.
Each triple has the form
&amp;lt;subject&amp;gt; &amp;lt;predicate&amp;gt; &amp;lt;object&amp;gt; . Meaning that the graph node identified by subject is linked to object with directed edge predicate. Each triple ends with a period. The subject of a triple is always a node in the graph, while the object may be a node or a value (a literal).</description></item><item><title>Blank Nodes and UIDs in DQL</title><link>/old/mutations/blank-nodes/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/blank-nodes/</guid><description>Blank nodes in mutations, written _:identifier, identify nodes within a mutation. Dgraph creates a UID identifying each blank node and returns the created UIDs as the mutation result. For example, mutation:
{ set { _:class &amp;lt;student&amp;gt; _:x . _:class &amp;lt;student&amp;gt; _:y . _:class &amp;lt;name&amp;gt; &amp;#34;awesome class&amp;#34; . _:class &amp;lt;dgraph.type&amp;gt; &amp;#34;Class&amp;#34; . _:x &amp;lt;name&amp;gt; &amp;#34;Alice&amp;#34; . _:x &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . _:x &amp;lt;dgraph.type&amp;gt; &amp;#34;Student&amp;#34; . _:x &amp;lt;planet&amp;gt; &amp;#34;Mars&amp;#34; . _:x &amp;lt;friend&amp;gt; _:y .</description></item><item><title>External IDs</title><link>/old/mutations/external-ids/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/external-ids/</guid><description>Dgraph&amp;rsquo;s input language, RDF, also supports triples of the form &amp;lt;a_fixed_identifier&amp;gt; &amp;lt;predicate&amp;gt; literal/node and variants on this, where the label a_fixed_identifier is intended as a unique identifier for a node. For example, mixing schema.org identifiers, the movie database identifiers and blank nodes:
_:userA &amp;lt;http://schema.org/type&amp;gt; &amp;lt;http://schema.org/Person&amp;gt; . _:userA &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . _:userA &amp;lt;http://schema.org/name&amp;gt; &amp;#34;FirstName LastName&amp;#34; . &amp;lt;https://www.themoviedb.org/person/32-robin-wright&amp;gt; &amp;lt;http://schema.org/type&amp;gt; &amp;lt;http://schema.org/Person&amp;gt; . &amp;lt;https://www.themoviedb.org/person/32-robin-wright&amp;gt; &amp;lt;http://schema.org/name&amp;gt; &amp;#34;Robin Wright&amp;#34; . As Dgraph doesn&amp;rsquo;t natively support such external IDs as node identifiers.</description></item><item><title>External IDs and Upsert Block</title><link>/old/mutations/external-ids-upsert-block/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/external-ids-upsert-block/</guid><description>The upsert block makes managing external IDs easy.
Set the schema.
xid: string @index(exact) . &amp;lt;http://schema.org/name&amp;gt;: string @index(exact) . &amp;lt;http://schema.org/type&amp;gt;: [uid] @reverse . Set the type first of all.
{ set { _:blank &amp;lt;xid&amp;gt; &amp;#34;http://schema.org/Person&amp;#34; . _:blank &amp;lt;dgraph.type&amp;gt; &amp;#34;ExternalType&amp;#34; . } } Now you can create a new person and attach its type using the upsert block.
upsert { query { var(func: eq(xid, &amp;#34;http://schema.org/Person&amp;#34;)) { Type as uid } var(func: eq(&amp;lt;http://schema.</description></item><item><title>Language and RDF Types</title><link>/old/mutations/language-rdf-types/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/language-rdf-types/</guid><description>RDF N-Quad allows specifying a language for string values and an RDF type. Languages are written using @lang. For example
&amp;lt;0x01&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Adelaide&amp;#34;@en . &amp;lt;0x01&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Аделаида&amp;#34;@ru . &amp;lt;0x01&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Adélaïde&amp;#34;@fr . &amp;lt;0x01&amp;gt; &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . See also how language strings are handled in queries.
RDF types are attached to literals with the standard ^^ separator. For example
&amp;lt;0x01&amp;gt; &amp;lt;age&amp;gt; &amp;#34;32&amp;#34;^^&amp;lt;xs:int&amp;gt; . &amp;lt;0x01&amp;gt; &amp;lt;birthdate&amp;gt; &amp;#34;1985-06-08&amp;#34;^^&amp;lt;xs:dateTime&amp;gt; . The supported RDF datatypes and the corresponding internal type in which the data is stored are as follows.</description></item><item><title>Batch Mutations in DQL</title><link>/old/mutations/batch-mutations/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/batch-mutations/</guid><description>Each mutation may contain multiple RDF triples. For large data uploads many such mutations can be batched in parallel. The command dgraph live does just this; by default batching 1000 RDF lines into a query, while running 100 such queries in parallel.
dgraph live takes as input gzipped N-Quad files (that is triple lists without { set {) and batches mutations for all triples in the input. The tool has documentation of options.</description></item><item><title>Delete Mutations in DQL</title><link>/old/mutations/delete/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/delete/</guid><description>A delete mutation, identified by the delete keyword, removes triples from the store.
For example, if the store contained the following:
&amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Lewis Carrol&amp;#34; &amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;died&amp;gt; &amp;#34;1998&amp;#34; &amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . Then, the following delete mutation deletes the specified erroneous data, and removes it from any indexes:
{ delete { &amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;died&amp;gt; &amp;#34;1998&amp;#34; . } } Wildcard delete In many cases you will need to delete multiple types of data for a predicate.</description></item><item><title>Facet Lists in RDF</title><link>/old/mutations/facets-in-list-type-with-rdf/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/facets-in-list-type-with-rdf/</guid><description>Schema:
&amp;lt;name&amp;gt;: string @index(exact). &amp;lt;nickname&amp;gt;: [string] . Creating a list with facets in RDF is straightforward.
{ set { _:Julian &amp;lt;name&amp;gt; &amp;#34;Julian&amp;#34; . _:Julian &amp;lt;nickname&amp;gt; &amp;#34;Jay-Jay&amp;#34; (kind=&amp;#34;first&amp;#34;) . _:Julian &amp;lt;nickname&amp;gt; &amp;#34;Jules&amp;#34; (kind=&amp;#34;official&amp;#34;) . _:Julian &amp;lt;nickname&amp;gt; &amp;#34;JB&amp;#34; (kind=&amp;#34;CS-GO&amp;#34;) . } } { q(func: eq(name,&amp;#34;Julian&amp;#34;)){ name nickname @facets } } Result:
{ &amp;#34;data&amp;#34;: { &amp;#34;q&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Julian&amp;#34;, &amp;#34;nickname|kind&amp;#34;: { &amp;#34;0&amp;#34;: &amp;#34;first&amp;#34;, &amp;#34;1&amp;#34;: &amp;#34;official&amp;#34;, &amp;#34;2&amp;#34;: &amp;#34;CS-GO&amp;#34; }, &amp;#34;nickname&amp;#34;: [ &amp;#34;Jay-Jay&amp;#34;, &amp;#34;Jules&amp;#34;, &amp;#34;JB&amp;#34; ] } ] } }</description></item><item><title>Mutations Using cURL</title><link>/old/mutations/mutations-using-curl/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/mutations-using-curl/</guid><description>Mutations can be done over HTTP by making a POST request to an Alpha&amp;rsquo;s /mutate endpoint. On the command line this can be done with curl. To commit the mutation, pass the parameter commitNow=true in the URL.
To run a set mutation:
curl -H &amp;#34;Content-Type: application/rdf&amp;#34; -X POST localhost:8080/mutate?commitNow=true -d $&amp;#39; { set { _:alice &amp;lt;name&amp;gt; &amp;#34;Alice&amp;#34; . _:alice &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . } }&amp;#39; To run a delete mutation:
curl -H &amp;#34;Content-Type: application/rdf&amp;#34; -X POST localhost:8080/mutate?</description></item><item><title>JSON Mutation Format</title><link>/old/mutations/json-mutation-format/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/json-mutation-format/</guid><description>Mutations can also be specified using JSON objects. This can allow mutations to be expressed in a more natural way. It also eliminates the need for apps to have custom serialization code, since most languages already have a JSON marshaling library.
When Dgraph receives a mutation as a JSON object, it first converts it into an internal edge format that is then processed into Dgraph.
JSON -&amp;gt; Edges -&amp;gt; Posting list RDF -&amp;gt; Edges -&amp;gt; Posting list</description></item><item><title>Upsert Blocks in DQL</title><link>/old/mutations/upsert-block/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/upsert-block/</guid><description>Upsert blocks allow you to perform both queries and mutations in a single request. The upsert block contains one query block and one or more than one mutation blocks. Variables defined in the query block can be used in the mutation blocks using the uid and val function.
In general, the structure of the upsert block is as follows:
upsert { query &amp;lt;query block&amp;gt; [fragment &amp;lt;fragment block&amp;gt;] mutation &amp;lt;mutation block 1&amp;gt; [mutation &amp;lt;mutation block 2&amp;gt;] .</description></item><item><title>Conditional Upsert</title><link>/old/mutations/conditional-upsert/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/conditional-upsert/</guid><description>The upsert block also allows specifying conditional mutation blocks using an @if directive. The mutation is executed only when the specified condition is true. If the condition is false, the mutation is silently ignored. The general structure of Conditional Upsert looks like as follows:
upsert { query &amp;lt;query block&amp;gt; [fragment &amp;lt;fragment block&amp;gt;] mutation [@if(&amp;lt;condition&amp;gt;)] &amp;lt;mutation block 1&amp;gt; [mutation [@if(&amp;lt;condition&amp;gt;)] &amp;lt;mutation block 2&amp;gt;] ... } The @if directive accepts a condition on variables defined in the query block and can be connected using AND, OR and NOT.</description></item><item><title>Reverse Edges</title><link>/old/mutations/reverse-edges/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/old/mutations/reverse-edges/</guid><description>Any outgoing edge in Dgraph can be reversed using the @reverse directive in the schema and be queried using tilde as the prefix of the edge name. e.g. &amp;lt;~myEdge&amp;gt;.
Dgraph serializes directed graphs. This means that all properties always point from an entity to another entity or value in a single direction. S P -&amp;gt; O.
Reverse edges are automatically generated edges and are not part of your dataset. This means that you cannot run mutations directly on the reverse edges.</description></item></channel></rss>