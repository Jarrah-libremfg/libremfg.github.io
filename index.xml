<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Get started with Libre Baas on</title><link>/</link><description>Recent content in Get started with Libre Baas on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Mar 2017 19:35:35 +1100</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Dgraph Administration</title><link>/deploy/dgraph-administration/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/dgraph-administration/</guid><description>Each Dgraph Alpha exposes various administrative (admin) endpoints both over HTTP and GraphQL, for example endpoints to export data and to perform a clean shutdown. All such admin endpoints are protected by three layers of authentication:
IP White-listing (use the --security superflag&amp;rsquo;s whitelist option on Dgraph Alpha to whitelist IP addresses other than localhost). Poor-man&amp;rsquo;s auth, if Dgraph Alpha is started with the --security superflag&amp;rsquo;s token option, then you should pass the token as an X-Dgraph-AuthToken header while making the HTTP request.</description></item><item><title>DQL Fundamentals</title><link>/query-language/graphql-fundamentals/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/graphql-fundamentals/</guid><description>Dgraph Query Language, DQL, (previously named GraphQL+-) is based on GraphQL maintained by the GraphQL Foundation. GraphQL wasn&amp;rsquo;t developed for Graph databases, but its graph-like query syntax, schema validation and subgraph shaped response make it a great language choice. We&amp;rsquo;ve modified the language to better support graph operations, adding and removing features to get the best fit for graph databases.
DQL is a work in progress. We&amp;rsquo;re adding more features and we might further simplify existing ones.</description></item><item><title>Overview</title><link>/deploy/fast-data-loading/overview/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/fast-data-loading/overview/</guid><description>There are two different tools that can be used for fast data loading:
dgraph live runs the Dgraph Live Loader dgraph bulk runs the Dgraph Bulk Loader Note Both tools only accept RDF N-Quad/Triple data or JSON in plain or gzipped format. Data in other formats must be converted. Live Loader Dgraph Live Loader (run with dgraph live) is a small helper program which reads RDF N-Quads from a gzipped file, batches them up, creates mutations (using the go client) and shoots off to Dgraph.</description></item><item><title>Ports Usage</title><link>/deploy/ports-usage/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/ports-usage/</guid><description>Dgraph cluster nodes use a range of ports to communicate over gRPC and HTTP. Choose these ports carefully based on your topology and mode of deployment, as this will impact the access security rules or firewall configurations required for each port.
Types of ports Dgraph Alpha and Dgraph Zero nodes use a variety of gRPC and HTTP ports, as follows:
gRPC-internal-private: Used between the cluster nodes for internal communication and message exchange.</description></item><item><title>Retrieving Debug Information</title><link>/howto/retrieving-debug-information/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/retrieving-debug-information/</guid><description>Each Dgraph data node exposes profile over /debug/pprof endpoint and metrics over /debug/vars endpoint. Each Dgraph data node has it&amp;rsquo;s own profiling and metrics information. Below is a list of debugging information exposed by Dgraph and the corresponding commands to retrieve them.
Metrics Information If you are collecting these metrics from outside the Dgraph instance you need to pass --expose_trace=true flag, otherwise there metrics can be collected by connecting to the instance over localhost.</description></item><item><title>Shell Completion</title><link>/howto/completion/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/completion/</guid><description>Command-line completion is a common feature provided by shells like bash or zsh that lets you type commands in a fast and easy way. This functionality automatically fills in partially typed commands when the user press the tab key.
Completion script The command-line interpreter requires a completion script to define which completion suggestions can be displayed for a given executable.
Using the dgraph completion command you can generate a file that can be added to your shell configuration.</description></item><item><title>Transactions: FAQ</title><link>/design-concepts/transactions-faq/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/transactions-faq/</guid><description>Dgraph supports distributed ACID transactions through snapshot isolation.
Can we do pre-writes only on leaders? Seems like a good idea, but has bad implications. If we only do a prewrite in-memory, only on leader, then this prewrite wouldn&amp;rsquo;t make it to the Raft log, or disk; but would be considered successful.
Then zero could mark the transaction as committed; but this leader could go down, or leadership could change. In such a case, we&amp;rsquo;d end up losing the transaction altogether despite it having been considered committed.</description></item><item><title>Triples in DQL</title><link>/mutations/triples/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/triples/</guid><description>A mutation that adds triples is done with the set keyword.
{ set { # triples in here } } The input language is triples in the W3C standard RDF N-Quad format.
Each triple has the form
&amp;lt;subject&amp;gt; &amp;lt;predicate&amp;gt; &amp;lt;object&amp;gt; . Meaning that the graph node identified by subject is linked to object with directed edge predicate. Each triple ends with a period. The subject of a triple is always a node in the graph, while the object may be a node or a value (a literal).</description></item><item><title>Custom Resolvers Overview</title><link>/graphql/custom/custom-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/custom-overview/</guid><description>Dgraph creates a GraphQL API from nothing more than GraphQL types. That&amp;rsquo;s great, and gets you moving fast from an idea to a running app. However, at some point, as your app develops, you might want to customize the behavior of your schema.
In Dgraph, you do that with code (in any language you like) that implements custom resolvers.
Dgraph doesn&amp;rsquo;t execute your custom logic itself. It makes external HTTP requests.</description></item><item><title>Deployment and Management Overview</title><link>/deploy/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/deploy/overview/</guid><description>You can deploy and manage Dgraph database in a variety of self-managed deployment scenarios, including:
Running Dgraph on your on-premises infrastructure (bare-metal physical servers) Running Dgraph on your cloud infrastructure (AWS, GCP and Azure) This section focuses exclusively on deployment and management for these self-managed scenarios. To learn about fully-managed options that let you focus on building apps and websites, rather than managing infrastructure, see the Dgraph cloud services docs, or Try Dgraph Cloud.</description></item><item><title>Dgraph Lambda Overview</title><link>/graphql/lambda/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/lambda/overview/</guid><description>Lambda provides a way to write your custom logic in JavaScript, integrate it with your GraphQL schema, and execute it using the GraphQL API in a few easy steps:
Set up a Dgraph cluster with a working lambda server (not required for Dgraph Cloud users) Declare lambda queries, mutations, and fields in your GraphQL schema as needed Define lambda resolvers for them in a JavaScript file This also simplifies the job of developers, as they can build a complex backend that is rich with business logic, without setting up multiple different services.</description></item><item><title>GraphQL Overview</title><link>/graphql/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/overview/</guid><description>Welcome to the official GraphQL documentation for Dgraph.
Designed from the ground up to be run in production, Dgraph is the native GraphQL database with a graph backend. It is open-source, scalable, distributed, highly available and lightning fast.
These docs tell you all the details. If you are looking for a walk through tutorial, then head over to our tutorials section. Dgraph gives you GraphQL. You&amp;rsquo;re always working with GraphQL, not a translation layer.</description></item><item><title>GraphQL Queries Overview</title><link>/graphql/queries/queries-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/queries-overview/</guid><description>This guide explains how to use GraphQL queries to fetch data from Dgraph.
Dgraph automatically generates GraphQL queries for each type that you define in your schema. There are three types of queries generated for each type.
Example schema:
type Post { id: ID! title: String! @search text: String score: Float @search completed: Boolean @search datePublished: DateTime @search(by: [year]) author: Author! } type Author { id: ID! name: String! @search posts: [Post!</description></item><item><title>Mutations Overview</title><link>/graphql/mutations/mutations-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/mutations-overview/</guid><description>Mutations allow you to modify server-side data, and it also returns an object based on the operation performed. It can be used to insert, update, or delete data. Dgraph automatically generates GraphQL mutations for each type that you define in your schema. The mutation field returns an object type that allows you to query for nested fields. This can be useful for fetching an object&amp;rsquo;s new state after an add/update, or to get the old state of an object before a delete.</description></item><item><title>Overview</title><link>/graphql/api/api-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/api-overview/</guid><description>How to use the GraphQL API.
Dgraph serves spec-compliant GraphQL over HTTP to two endpoints: /graphql and /admin.
In Dgraph Cloud /graphql and /admin are served from the domain of your backend, which will be something like https://YOUR-SUBDOMAIN.REGION.aws.cloud.dgraph.io. If you are running a self-hosted Dgraph instance that will be at the alpha port and url (which defaults to http://localhost:8080 if you aren&amp;rsquo;t changing any settings).
In each case, both GET and POST requests are served.</description></item><item><title>Overview</title><link>/graphql/schema/schema-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/schema-overview/</guid><description>This section describes all the things you can put in your input GraphQL schema, and what gets generated from that.
The process for serving GraphQL with Dgraph is to add a set of GraphQL type definitions using the /admin endpoint. Dgraph takes those definitions, generates queries and mutations, and serves the generated GraphQL schema.
The input schema may contain interfaces, types and enums that follow the usual GraphQL syntax and validation rules.</description></item><item><title>Overview</title><link>/graphql/todo-app-tutorial/todo-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/todo-app-tutorial/todo-overview/</guid><description>This is a simple tutorial that will take you through making a basic to-do list app using Dgraph&amp;rsquo;s GraphQL API and integrating it with third-party authentication (Auth0 or Firebase).
Steps Schema Design Basic UI Add Auth Rules Use Auth0&amp;rsquo;s JWT Use Firebase&amp;rsquo;s JWT Deploy on Dgraph Cloud</description></item><item><title>Overview of Authorization and Authentication with GraphQL</title><link>/graphql/authorization/authorization-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/authorization/authorization-overview/</guid><description>Dgraph&amp;rsquo;s GraphQL implementation comes with built-in authorization. This lets you annotate your schema with rules that determine who can query and mutate your data.
First, let&amp;rsquo;s get some concepts defined. There are two important concepts included in what&amp;rsquo;s often called auth:
Authorization: access permissions (what are you allowed to do) Authentication: establishment of identity (who you are) Dgraph lets you use your GraphQL schema to manage both authorization and authentication:</description></item><item><title>Reserved Names in GraphQL</title><link>/graphql/schema/reserved/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/reserved/</guid><description>The following names are reserved and can&amp;rsquo;t be used to define any other identifiers:
Int Float Boolean String DateTime ID uid Subscription as (case-insensitive) Query Mutation Point PointList Polygon MultiPolygon Aggregate (as a suffix of any identifier name) For each type, Dgraph generates a number of GraphQL types needed to operate the GraphQL API, these generated type names also can&amp;rsquo;t be present in the input schema. For example, for a type Author, Dgraph generates:</description></item><item><title>Schema Migration</title><link>/graphql/schema/migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/migration/</guid><description>In every app&amp;rsquo;s development lifecycle, there&amp;rsquo;s a point where the underlying schema doesn&amp;rsquo;t fit the requirements and must be changed for good. That requires a migration for both schema and the underlying data. This article will guide you through common migration scenarios you can encounter with Dgraph and help you avoid any pitfalls around them.
These are the most common scenarios that can occur:
Renaming a type Renaming a field Changing a field&amp;rsquo;s type Adding @id to an existing field Note As long as you can avoid migration, avoid it.</description></item><item><title>Audit Logging</title><link>/enterprise-features/audit-logs/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/enterprise-features/audit-logs/</guid><description>As a database administrator, you count on being able to audit access to your database. With a Dgraph enterprise license, you can enable audit logging so that all requests are tracked and available for use in security audits. When audit logging is enabled, the following information is recorded about the queries and mutations (requests) sent to your database:
Endpoint Logged-in User Name Server host address Client Host address Request Body (truncated at 4KB) Timestamp Namespace Query Parameters (if provided) Response status Audit log scope Most queries and mutations sent to Dgraph Alpha and Dgraph Zero are logged.</description></item><item><title>Blank Nodes and UIDs in DQL</title><link>/mutations/blank-nodes/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/blank-nodes/</guid><description>Blank nodes in mutations, written _:identifier, identify nodes within a mutation. Dgraph creates a UID identifying each blank node and returns the created UIDs as the mutation result. For example, mutation:
{ set { _:class &amp;lt;student&amp;gt; _:x . _:class &amp;lt;student&amp;gt; _:y . _:class &amp;lt;name&amp;gt; &amp;#34;awesome class&amp;#34; . _:class &amp;lt;dgraph.type&amp;gt; &amp;#34;Class&amp;#34; . _:x &amp;lt;name&amp;gt; &amp;#34;Alice&amp;#34; . _:x &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . _:x &amp;lt;dgraph.type&amp;gt; &amp;#34;Student&amp;#34; . _:x &amp;lt;planet&amp;gt; &amp;#34;Mars&amp;#34; . _:x &amp;lt;friend&amp;gt; _:y .</description></item><item><title>Consistency Model</title><link>/design-concepts/consistency-model/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/consistency-model/</guid><description>[Update on Jan 15, 2020]
Dgraph supports MVCC, Read Snapshots and Distributed ACID transactions. The transactions are cluster-wide (not key-only, or any other &amp;ldquo;crippled&amp;rdquo; version of them). Transactions are lockless. They don&amp;rsquo;t block/wait on seeing pending writes by uncommitted transactions. Zero would choose to commit or abort them depending on conflicts. Transactions are based on Snapshot Isolation (not Serializable Snapshot Isolation), because conflicts are determined by writes (not reads). Dgraph hands out monotonically increasing timestamps (for transactions).</description></item><item><title>Download Dgraph</title><link>/deploy/download/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/download/</guid><description>Dgraph is available to download in a variety of ways:
Tip For a single server setup, recommended for new users, please see Get Started page. Docker docker pull dgraph/dgraph: # You can test that it worked fine, by running: docker run -it dgraph/dgraph: dgraph Automatic download Running
curl https://get.dgraph.io -sSf | bash # Test that it worked fine, by running: dgraph would install the dgraph binary into your system.
Other installation options:</description></item><item><title>Functions with DQL</title><link>/query-language/functions/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/functions/</guid><description>Dgraph Query Language (DQL) functions allow filtering based on properties of nodes or variables. Functions can be applied in the query root or in filters.
Comparison functions (eq, ge, gt, le, lt) in the query root (aka func:) can only be applied on indexed predicates. Since v1.2, comparison functions can now be used on @filter directives even on predicates that have not been indexed. Filtering on non-indexed predicates can be slow for large datasets, as they require iterating over all of the possible values at the level where the filter is being used.</description></item><item><title>Logging</title><link>/deploy/log-format/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/log-format/</guid><description>Dgraph logs requests for queries and mutations, and also provides audit logging capabilities with a Dgraph enterprise license.
Dgraph&amp;rsquo;s log format comes from the glog library and is formatted as follows:
Lmmdd hh:mm:ss.uuuuuu threadid file:line] msg... The fields shown above are defined as follows:
Field Definition L A single character, representing the log level (eg &amp;lsquo;I&amp;rsquo; for INFO) mm Month (zero padded; ie May is &amp;lsquo;05&amp;rsquo;) dd Day (zero padded) hh:mm:ss.</description></item><item><title>TLS Configuration</title><link>/deploy/tls-configuration/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/tls-configuration/</guid><description>Connections between Dgraph database and its clients can be secured using TLS. In addition, Dgraph can now secure gRPC communications between Dgraph Alpha and Dgraph Zero server nodes using mutual TLS (mTLS). Dgraph can now also secure communications over the Dgraph Zero gRPC-external-private port used by Dgraph&amp;rsquo;s Live Loader and Bulk Loader clients. To learn more about the HTTP and gRPC ports used by Dgraph Alpha and Dgraph Zero, see Ports Usage.</description></item><item><title>Using the Debug Tool</title><link>/howto/using-debug-tool/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/using-debug-tool/</guid><description>Note To debug a running Dgraph cluster, first copy the postings (&amp;ldquo;p&amp;rdquo;) directory to another location. If the Dgraph cluster is not running, then you can use the same postings directory with the debug tool.
If the “p” directory has been encrypted, then the debug tool will need to use the &amp;ndash;keyfile option. This file must contain the same key that was used to encrypt the “p” directory.
The dgraph debug tool can be used to inspect Dgraph&amp;rsquo;s posting list structure.</description></item><item><title>Add Mutations in GraphQL</title><link>/graphql/mutations/add/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/add/</guid><description>Add mutations allow you to add new objects of a particular type.
We use the following schema to demonstrate some examples.
Schema:
type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String! @search(by: [term, fulltext]) text: String @search(by: [fulltext, term]) datePublished: DateTime } Dgraph automatically generates input and return types in the schema for the add mutation, as shown below:</description></item><item><title>Lambda Fields</title><link>/graphql/lambda/field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/lambda/field/</guid><description>Schema To set up a lambda function, first you need to define it on your GraphQL schema by using the @lambda directive.
For example, to define a lambda function for the rank and bio fields in Author:
type Author { id: ID! name: String! @search(by: [hash, trigram]) dob: DateTime @search reputation: Float @search bio: String @lambda rank: Int @lambda isMe: Boolean @lambda } You can also define @lambda fields on interfaces, as follows:</description></item><item><title>Quick Start</title><link>/graphql/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/quick-start/</guid><description>Let&amp;rsquo;s go from nothing to a running GraphQL API in just two steps.
For GraphQL in Dgraph, you just concentrate on defining the schema of your graph and how you&amp;rsquo;d like to search that graph; Dgraph does the rest. You work only with GraphQL and, think in terms of the graph that matters for your app.
This example is for an app about customers, products and reviews. That&amp;rsquo;s a pretty simple graph, with just three types of objects, but it has some interesting connections for us to explore.</description></item><item><title>Requests and Responses in GraphQL</title><link>/graphql/api/requests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/requests/</guid><description>In this section, we&amp;rsquo;ll cover the structure for GraphQL requests and responses, how to enable compression for them, and configuration options for extensions.
Requests GraphQL requests can be sent via HTTP POST or HTTP GET requests.
POST requests sent with the Content-Type header application/graphql must have a POST body content as a GraphQL query string. For example, the following is a valid POST body for a query:
query { getTask(id: &amp;#34;0x3&amp;#34;) { id title completed user { username name } } } POST requests sent with the Content-Type header application/json must have a POST body in the following JSON format:</description></item><item><title>Schema Design</title><link>/graphql/todo-app-tutorial/todo-schema-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/todo-app-tutorial/todo-schema-design/</guid><description>Let&amp;rsquo;s start with listing down the entities that are involved in a basic todo app.
Task User Equivalent GraphQL schema for the graph above would be as follow:
type Task { ... } type User { ... } What are the fields that these two simple entities contain?
We have a title and a status to check if it was completed or not in the Task type. Then the User type has a username (unique identifier), name and the tasks.</description></item><item><title>Search and Filtering</title><link>/graphql/queries/search-filtering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/search-filtering/</guid><description>Queries generated for a GraphQL type allow you to generate a single list of objects for a type.
Get a single object Fetch the title, text and datePublished for a post with id 0x1.
query { getPost(id: &amp;#34;0x1&amp;#34;) { title text datePublished } } Fetching nested linked objects, while using get queries is also easy. For example, this is how you would fetch the authors for a post and their friends.</description></item><item><title>The @auth Directive in GraphQL</title><link>/graphql/authorization/directive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/authorization/directive/</guid><description>The @auth directive tells Dgraph how to apply authorization. You can use it to define authorization rules for most types (except for union and @remote types). It lets you control which users can run which queries - as well as which users can add, update, and delete data using mutations.
Additionally, you can use this directive with the @secret directive; and, if you specify a password authorization rule, Dgraph will use it to authorize the check&amp;lt;Type&amp;gt;Password query.</description></item><item><title>The @custom Directive</title><link>/graphql/custom/directive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/directive/</guid><description>The @custom directive is used to define custom queries, mutations and fields.
In all cases, the result type (of the query, mutation or field) can be either:
a type that&amp;rsquo;s stored in Dgraph (that&amp;rsquo;s any type you&amp;rsquo;ve defined in your schema), or a type that&amp;rsquo;s not stored in Dgraph and is marked with the @remote directive. Because the result types can be local or remote, you can call other HTTP endpoints, call remote GraphQL, or even call back to your Dgraph instance to add extra logic on top of Dgraph&amp;rsquo;s graph search or mutations.</description></item><item><title>Types in GraphQL</title><link>/graphql/schema/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/types/</guid><description>This page describes how you can use GraphQL types to set up a GraphQL schema for Dgraph database.
Scalars Dgraph&amp;rsquo;s GraphQL implementation comes with the standard GraphQL scalar types: Int, Float, String, Boolean and ID. There&amp;rsquo;s also an Int64 scalar, and a DateTime scalar type that is represented as a string in RFC3339 format.
Scalar types, including Int, Int64, Float, String and DateTime; can be used in lists. Lists behave like an unordered set in Dgraph.</description></item><item><title>Upsert Mutations</title><link>/graphql/mutations/upsert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/upsert/</guid><description>Upsert mutations allow you to perform add or update operations based on whether a particular ID exists in the database. The IDs must be external IDs, defined using the @id directive in the schema.
For example, to demonstrate how upserts work in GraphQL, take the following schema:
Schema
type Author { id: String! @id name: String! @search(by: [hash]) posts: [Post] @hasInverse(field: author) } type Post { postID: String! @id title: String!</description></item><item><title>Backup List Tool</title><link>/enterprise-features/lsbackup/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/enterprise-features/lsbackup/</guid><description>The lsbackup command-line tool prints information about the stored backups in a user-defined location.
Parameters The lsbackup command has two flags:
Flags: -h, --help help for lsbackup -l, --location string Sets the source location URI (required). --verbose Outputs additional info in backup list. --location: indicates a source URI with Dgraph backup objects. This URI supports all the schemes used for backup. --verbose: if enabled will print additional information about the selected backup.</description></item><item><title>Concepts</title><link>/design-concepts/concepts/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/concepts/</guid><description>Edges Typical data format is RDF N-Quad which is:
Subject, Predicate, Object, Label, aka Entity, Attribute, Other Entity / Value, Label Both the terminologies get used interchangeably in our code. Dgraph considers edges to be directional, i.e. from Subject -&amp;gt; Object. This is the direction that the queries would be run.
Tip Dgraph can automatically generate a reverse edge. If the user wants to run queries in that direction, they would need to define the reverse edge as part of the schema.</description></item><item><title>Configuration</title><link>/deploy/config/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/config/</guid><description>Tip For a single server setup, recommended for new users, please see Get Started page. You can see the list of available subcommands with dgraph --help. You can view the full set of configuration options for a given subcommand with dgraph &amp;lt;subcommand&amp;gt; --help (for example, dgraph zero --help).
You can configure options in multiple ways, which are listed below from highest precedence to lowest precedence:
Using command line flags (as described in the help output).</description></item><item><title>Connecting Filters</title><link>/query-language/connecting-filters/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/connecting-filters/</guid><description>Within @filter multiple functions can be used with boolean connectives.
AND, OR and NOT Connectives AND, OR and NOT join filters and can be built into arbitrarily complex filters, such as (NOT A OR B) AND (C AND NOT (D OR E)). Note that, NOT binds more tightly than AND which binds more tightly than OR.
Query Example : All Steven Spielberg movies that contain either both &amp;ldquo;indiana&amp;rdquo; and &amp;ldquo;jones&amp;rdquo; OR both &amp;ldquo;jurassic&amp;rdquo; and &amp;ldquo;park&amp;rdquo;.</description></item><item><title>External IDs</title><link>/mutations/external-ids/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/external-ids/</guid><description>Dgraph&amp;rsquo;s input language, RDF, also supports triples of the form &amp;lt;a_fixed_identifier&amp;gt; &amp;lt;predicate&amp;gt; literal/node and variants on this, where the label a_fixed_identifier is intended as a unique identifier for a node. For example, mixing schema.org identifiers, the movie database identifiers and blank nodes:
_:userA &amp;lt;http://schema.org/type&amp;gt; &amp;lt;http://schema.org/Person&amp;gt; . _:userA &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . _:userA &amp;lt;http://schema.org/name&amp;gt; &amp;#34;FirstName LastName&amp;#34; . &amp;lt;https://www.themoviedb.org/person/32-robin-wright&amp;gt; &amp;lt;http://schema.org/type&amp;gt; &amp;lt;http://schema.org/Person&amp;gt; . &amp;lt;https://www.themoviedb.org/person/32-robin-wright&amp;gt; &amp;lt;http://schema.org/name&amp;gt; &amp;#34;Robin Wright&amp;#34; . As Dgraph doesn&amp;rsquo;t natively support such external IDs as node identifiers.</description></item><item><title>Ludicrous Mode</title><link>/deploy/ludicrous-mode/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/ludicrous-mode/</guid><description>Ludicrous mode is available in Dgraph v20.03.1 and later.
Ludicrous mode allows a Dgraph database to ingest data at an incredibly fast speed, but with fewer guarantees. In normal mode, Dgraph provides strong consistency. In Ludicrous mode, Dgraph provides eventual consistency, so any mutation that succeeds should be available eventually. This means changes are applied more slowly during periods of peak data ingestion, and might not be immediately reflected in query results.</description></item><item><title>Using the Dgraph Sentry Integration</title><link>/howto/dgraph-sentry-integration/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/dgraph-sentry-integration/</guid><description>Sentry is a powerful service that allows applications to send arbitrary events, messages, exceptions, bread-crumbs (logs) to your sentry account. In simplest terms, it is a dial-home service but also has a rich feature set including event filtering, data scrubbing, several SDKs, custom and release tagging, as well as integration with 3rd party tools such as Slack, GitHub.
Although Sentry reporting is on by default, starting from v20.03.1 and v20.07.0, there is a configuration flag enable-sentry which can be used to completely turn off Sentry events reporting.</description></item><item><title>Aggregate Queries</title><link>/graphql/queries/aggregate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/aggregate/</guid><description>Dgraph automatically generates aggregate queries for GraphQL schemas. Aggregate queries fetch aggregate data, including the following:
Count queries that let you count fields satisfying certain criteria specified using a filter. Advanced aggregate queries that let you calculate the maximum, minimum, sum and average of specified fields. Aggregate queries are compatible with the @auth directive and follow the same authorization rules as the query keyword. You can also use filters with aggregate queries, as shown in some of the examples provided below.</description></item><item><title>Creating a Basic UI</title><link>/graphql/todo-app-tutorial/todo-ui/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/todo-app-tutorial/todo-ui/</guid><description>In this step, we will create a simple to-do app (in React) and integrate it with Auth0.
Create React app Let&amp;rsquo;s start by creating a React app using the create-react-app command.
npx create-react-app todo-react-app To verify navigate to the folder, start the dev server, and visit http://localhost:3000.
cd todo-react-app npm start Refer this step in GitHub.
Install dependencies Now, let&amp;rsquo;s install the various dependencies that we will need in the app.</description></item><item><title>Custom Queries</title><link>/graphql/custom/query/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/query/</guid><description>Let&amp;rsquo;s say we want to integrate our app with an existing external REST API. There&amp;rsquo;s a few things we need to know:
The URL of the API, the path and any parameters required The shape of the resulting JSON data The method (GET, POST, etc.), and What authorization we need to pass to the external endpoint The custom query can take any number of scalar arguments and use those to construct the path, parameters and body (we&amp;rsquo;ll see an example of that in the custom mutation section) of the request that gets sent to the remote endpoint.</description></item><item><title>GraphQL Variables</title><link>/graphql/api/variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/variables/</guid><description>Variables simplify GraphQL queries and mutations by letting you pass data separately. A GraphQL request can be split into two sections: one for the query or mutation, and another for variables.
Variables can be declared after the query or mutation and are passed like arguments to a function and begin with $.
Query Example : query post($filter: PostFilter) { queryPost(filter: $filter) { title text author { name } } } Variables: { &amp;#34;filter&amp;#34;: { &amp;#34;title&amp;#34;: { &amp;#34;eq&amp;#34;: &amp;#34;First Post&amp;#34; } } } Result: { &amp;#34;data&amp;#34;: { &amp;#34;queryPost&amp;#34;: [{ &amp;#34;title&amp;#34;: &amp;#34;First Post&amp;#34;, &amp;#34;text&amp;#34;: &amp;#34;Hello world!</description></item><item><title>How GraphQL works in Dgraph</title><link>/graphql/how-dgraph-graphql-works/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/how-dgraph-graphql-works/</guid><description>Dgraph is a GraphQL database. That means, with Dgraph, you design your application in GraphQL, you iterate on your app in GraphQL and, when you need it, you scale with GraphQL.
You design a set of GraphQL types that describes your requirements. Dgraph takes those types, prepares graph storage for them and generates a GraphQL API with queries and mutations.
You design a graph, store a graph and query a graph.</description></item><item><title>IDs in GraphQL</title><link>/graphql/schema/ids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/ids/</guid><description>Dgraph provides two types of built-in identifiers: the ID scalar type and the @id directive.
The ID scalar type is used when you don&amp;rsquo;t need to set an identifier outside of Dgraph. The @id directive is used for external identifiers, such as email addresses. The ID type In Dgraph, every node has a unique 64-bit identifier that you can expose in GraphQL using the ID type. An ID is auto-generated, immutable and never reused.</description></item><item><title>Lambda Queries</title><link>/graphql/lambda/query/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/lambda/query/</guid><description>Schema To set up a lambda query, first you need to define it on your GraphQL schema by using the @lambda directive.
Note get, query, and aggregate are reserved prefixes and they can&amp;rsquo;t be used to define Lambda queries. For example, to define a lambda query for Author that finds out authors given an author&amp;rsquo;s name:
type Author { id: ID! name: String! @search(by: [hash, trigram]) dob: DateTime reputation: Float } type Query { authorsByName(name: String!</description></item><item><title>Mutations and GraphQL Authorization</title><link>/graphql/authorization/mutations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/authorization/mutations/</guid><description>Mutations with authorization work like queries. But because mutations involve a state change in the database, it&amp;rsquo;s important to understand when the authorization rules are applied and what they mean.
Add Rules for add authorization state that the rule must hold of nodes created by the mutation data once committed to the database.
For example, a rule such as the following:
type Todo @auth( add: { rule: &amp;#34;&amp;#34;&amp;#34; query ($USER: String!</description></item><item><title>Update Mutations in GraphQL</title><link>/graphql/mutations/update/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/update/</guid><description>Update mutations let you update existing objects of a particular type. With update mutations, you can filter nodes and set or remove any field belonging to a type.
We use the following schema to demonstrate some examples.
Schema:
type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String! @search(by: [term, fulltext]) text: String @search(by: [fulltext, term]) datePublished: DateTime } Dgraph automatically generates input and return types in the schema for the update mutation.</description></item><item><title>Aliases</title><link>/query-language/alias/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/alias/</guid><description>Syntax Examples:
aliasName : predicate aliasName : predicate { ... } aliasName : varName as ... aliasName : count(predicate) aliasName : max(val(varName)) An alias provides an alternate name in results. Predicates, variables and aggregates can be aliased by prefixing with the alias name and :. Aliases do not have to be different to the original predicate name, but, within a block, an alias must be distinct from predicate names and other aliases returned in the same block.</description></item><item><title>Binary Backups</title><link>/enterprise-features/binary-backups/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/enterprise-features/binary-backups/</guid><description>Note This feature was introduced in v1.1.0. Binary backups are full backups of Dgraph that are backed up directly to cloud storage such as Amazon S3 or any Minio storage backend. Backups can also be saved to an on-premise network file system shared by all Alpha servers. These backups can be used to restore a new Dgraph cluster to the previous state from the backup. Unlike exports, binary backups are Dgraph-specific and can be used to restore a cluster quickly.</description></item><item><title>External IDs and Upsert Block</title><link>/mutations/external-ids-upsert-block/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/external-ids-upsert-block/</guid><description>The upsert block makes managing external IDs easy.
Set the schema.
xid: string @index(exact) . &amp;lt;http://schema.org/name&amp;gt;: string @index(exact) . &amp;lt;http://schema.org/type&amp;gt;: [uid] @reverse . Set the type first of all.
{ set { _:blank &amp;lt;xid&amp;gt; &amp;#34;http://schema.org/Person&amp;#34; . _:blank &amp;lt;dgraph.type&amp;gt; &amp;#34;ExternalType&amp;#34; . } } Now you can create a new person and attach its type using the upsert block.
upsert { query { var(func: eq(xid, &amp;#34;http://schema.org/Person&amp;#34;)) { Type as uid } var(func: eq(&amp;lt;http://schema.</description></item><item><title>How Dgraph Minimizes Network Calls</title><link>/design-concepts/minimizing-network-calls/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/minimizing-network-calls/</guid><description>To explain how Dgraph minimizes network calls, let&amp;rsquo;s start with an example query we should be able to run.
Find all posts liked by friends of friends of mine over the last year, written by a popular author X.
SQL/NoSQL In a distributed SQL/NoSQL database, this would require you to retrieve a lot of data.
Method 1:
Find all the friends (~ 338 friends). Find all their friends (~ 338 * 338 = 40,000 people).</description></item><item><title>Monitoring</title><link>/deploy/monitoring/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/monitoring/</guid><description>Dgraph exposes metrics via the /debug/vars endpoint in json format and the /debug/prometheus_metrics endpoint in Prometheus&amp;rsquo;s text-based format. Dgraph doesn&amp;rsquo;t store the metrics and only exposes the value of the metrics at that instant. You can either poll this endpoint to get the data in your monitoring systems or install Prometheus. Replace targets in the below config file with the ip of your Dgraph instances and run prometheus using the command prometheus --config.</description></item><item><title>More about Dgraph Zero</title><link>/deploy/dgraph-zero/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/dgraph-zero/</guid><description>Dgraph Zero controls the Dgraph cluster, and stores information about it. It automatically moves data between different Dgraph Alpha instances based on the size of the data served by each Alpha instance.
Before you can run dgraph alpha, you must run at least one dgraph zero node. You can see the options available for dgraph zero by using the following command:
dgraph zero --help The --replicas option controls the replication factor: the number of replicas per data shard, including the original shard.</description></item><item><title>Using the Increment Tool</title><link>/howto/using-increment-tool/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/using-increment-tool/</guid><description>The dgraph increment tool increments a counter value transactionally. The increment tool can be used as a health check that an Alpha is able to service transactions for both queries and mutations.
Example Usage Increment the default predicate (counter.val) once. If the predicate doesn&amp;rsquo;t yet exist, then it will be created starting at counter 0.
$ dgraph increment Increment the counter predicate against the Alpha running at address --alpha (default: localhost:9080):</description></item><item><title>Authorization Rules</title><link>/graphql/todo-app-tutorial/todo-auth-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/todo-app-tutorial/todo-auth-rules/</guid><description>In the current state of the app, we can view anyone&amp;rsquo;s todos, but we want our to-dos to be private to us. Let&amp;rsquo;s do that using the @auth directive to limit that to the user&amp;rsquo;s to-dos.
We want to limit the user to its own to-dos, so we will define the query in auth to filter depending on the user&amp;rsquo;s username.
Let&amp;rsquo;s update the schema to include that, and then let&amp;rsquo;s understand what is happening there -</description></item><item><title>Custom Mutations</title><link>/graphql/custom/mutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/mutation/</guid><description>With custom mutations, you can use custom logic to define values for one or more fields in a mutation.
Let&amp;rsquo;s say we have an application about authors and posts. Logged in authors can add posts, but we want to do some input validation and add extra value when a post is added. The key types might be as follows.
type Author { ... } type Post { id: ID: title: String text: String datePublished: DateTime author: Author .</description></item><item><title>Delete Mutations in GraphQL</title><link>/graphql/mutations/delete/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/delete/</guid><description>Delete Mutations allow you to delete objects of a particular type.
We use the following schema to demonstrate some examples.
Schema:
type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String! @search(by: [term, fulltext]) text: String @search(by: [fulltext, term]) datePublished: DateTime } Dgraph automatically generates input and return types in the schema for the delete mutation. Delete mutations take filter as an input to select specific objects and returns the state of the objects before deletion.</description></item><item><title>GraphQL Fragments</title><link>/graphql/api/fragments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/fragments/</guid><description>A GraphQL fragment is a reusable unit of logic that can be shared between multiple queries and mutations. Here, we declare a postData fragment that can be used with any Post object:
fragment postData on Post { id title text author { username displayName } } The fragment has a subset of the fields from its associated type. In the above example, the Post type must declare all the fields present in the postData fragment for it be valid.</description></item><item><title>Lambda Mutations</title><link>/graphql/lambda/mutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/lambda/mutation/</guid><description>Schema To set up a lambda mutation, first you need to define it on your GraphQL schema by using the @lambda directive.
Note add, update, and delete are reserved prefixes and they can&amp;rsquo;t be used to define Lambda mutations. For example, to define a lambda mutation for Author that creates a new author with a default reputation of 3.0 given just the name:
type Author { id: ID! name: String! @search(by: [hash, trigram]) dob: DateTime reputation: Float } type Mutation { newAuthor(name: String!</description></item><item><title>Links in the GraphQL Graph</title><link>/graphql/schema/graph-links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/graph-links/</guid><description>All the data in your app forms a GraphQL data graph. That graph has nodes of particular types (the types you define in your schema) and links between the nodes to form the data graph.
Dgraph uses the types and fields in the schema to work out how to link that graph, what to accept for mutations and what shape responses should take.
Edges in that graph are directed: either pointing in one direction or two.</description></item><item><title>Persistent Queries</title><link>/graphql/queries/persistent-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/persistent-queries/</guid><description>Dgraph supports Persistent Queries. When a client uses persistent queries, the client only sends the hash of a query to the server. The server has a list of known hashes and uses the associated query accordingly.
Persistent queries significantly improve the performance and the security of an application since the smaller hash signature reduces bandwidth utilization and speeds up client loading times.
Persisted Query logic The execution of Persistent Queries follows this logic:</description></item><item><title>Giving Nodes a Type</title><link>/howto/giving-nodes-type/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/giving-nodes-type/</guid><description>It&amp;rsquo;s often useful to give the nodes in a graph types (also commonly referred to as labels or kinds). You can do so using the type system.</description></item><item><title>Language and RDF Types</title><link>/mutations/language-rdf-types/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/language-rdf-types/</guid><description>RDF N-Quad allows specifying a language for string values and an RDF type. Languages are written using @lang. For example
&amp;lt;0x01&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Adelaide&amp;#34;@en . &amp;lt;0x01&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Аделаида&amp;#34;@ru . &amp;lt;0x01&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Adélaïde&amp;#34;@fr . &amp;lt;0x01&amp;gt; &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . See also how language strings are handled in queries.
RDF types are attached to literals with the standard ^^ separator. For example
&amp;lt;0x01&amp;gt; &amp;lt;age&amp;gt; &amp;#34;32&amp;#34;^^&amp;lt;xs:int&amp;gt; . &amp;lt;0x01&amp;gt; &amp;lt;birthdate&amp;gt; &amp;#34;1985-06-08&amp;#34;^^&amp;lt;xs:dateTime&amp;gt; . The supported RDF datatypes and the corresponding internal type in which the data is stored are as follows.</description></item><item><title>Metrics</title><link>/deploy/metrics/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/metrics/</guid><description>Dgraph database provides metrics on Dgraph instance activity, disk activity, server node health, memory, and Raft leadership. It also provides built-in metrics provided by Go. Dgraph metrics follow the metric and label conventions for the Prometheus monitoring and alerting toolkit.
Activity Metrics Activity metrics let you track the mutations, queries, and proposals of a Dgraph instance.
Metric Description go_goroutines Total number of Goroutines currently running in Dgraph. dgraph_active_mutations_total Total number of mutations currently running.</description></item><item><title>More about Dgraph Alpha</title><link>/deploy/dgraph-alpha/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/dgraph-alpha/</guid><description>Dgraph Alpha provides several HTTP endpoints for administrators, as follows:
/health?all returns information about the health of all the servers in the cluster. /admin/shutdown initiates a proper shutdown of the Alpha. By default the Alpha listens on localhost for admin actions (the loopback address only accessible from the same machine). The --bindall=true option binds to 0.0.0.0 and thus allows external connections.
Tip Set max file descriptors to a high value like 10000 if you are going to load a lot of data.</description></item><item><title>Pagination in DQL</title><link>/query-language/pagination/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/pagination/</guid><description>Pagination allows returning only a portion, rather than the whole, result set. This can be useful for top-k style queries as well as to reduce the size of the result set for client side processing or to allow paged access to results.
Pagination is often used with sorting.
Note Without a sort order specified, the results are sorted by uid, which is assigned randomly. So the ordering, while deterministic, might not be what you expected.</description></item><item><title>RAFT</title><link>/design-concepts/raft/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/design-concepts/raft/</guid><description>This section aims to explain the RAFT consensus algorithm in simple terms. The idea is to give you just enough to make you understand the basic concepts, without going into explanations about why it works accurately. For a detailed explanation of RAFT, please read the original thesis paper by Diego Ongaro.
Term Each election cycle is considered a term, during which there is a single leader (just like in a democracy).</description></item><item><title>And, Or and Not Operators in GraphQL</title><link>/graphql/queries/and-or-not/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/and-or-not/</guid><description>Every GraphQL search filter can use and, or, and not operators.
GraphQL syntax uses infix notation, so: &amp;ldquo;a and b&amp;rdquo; is a, and: { b }, &amp;ldquo;a or b or c&amp;rdquo; is a, or: { b, or: c }, and &amp;ldquo;not&amp;rdquo; is a prefix (not:).
The following example queries demonstrate the use of and, or, and not operators:
Example: &amp;ldquo;Posts that do not have &amp;ldquo;GraphQL&amp;rdquo; in the title&amp;rdquo;
queryPost(filter: { not: { title: { allofterms: &amp;#34;GraphQL&amp;#34;} } } ) { .</description></item><item><title>Custom Fields</title><link>/graphql/custom/field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/field/</guid><description>Custom fields allow you to extend your types with custom logic as well as make joins between your local data and remote data.
Let&amp;rsquo;s say we are building an app for managing projects. Users will login with their GitHub id and we want to connect some data about their work stored in Dgraph with say their GitHub profile, issues, etc.
Our first version of our users might start out with just their GitHub username and some data about what projects they are working on.</description></item><item><title>Deep Mutations</title><link>/graphql/mutations/deep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/mutations/deep/</guid><description>You can perform deep mutations at multiple levels. Deep mutations do not alter linked objects, but they can add deeply-nested new objects or link to existing objects. To update an existing nested object, use the update mutation for its type.
We use the following schema to demonstrate some examples.
Schema: type Author { id: ID! name: String! @search(by: [hash]) dob: DateTime posts: [Post] } type Post { postID: ID! title: String!</description></item><item><title>Lambda Webhooks</title><link>/graphql/lambda/webhook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/lambda/webhook/</guid><description>Schema To set up a lambda webhook, you need to define it in your GraphQL schema by using the @lambdaOnMutate directive along with the mutation events (add/update/delete) you want to listen on.
Note Lambda webhooks only listen for events from the root mutation. You can create a schema that is capable of creating deeply nested objects, but only the parent level webhooks will be evoked for the mutation. For example, to define a lambda webhook for all mutation events (add/update/delete) on any Author object:</description></item><item><title>Multiple GraphQL Operations in a Request</title><link>/graphql/api/multiples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/multiples/</guid><description>GraphQL requests can contain one or more operations. Operations include query, mutation, or subscription. If a request only has one operation, then it can be unnamed like the following:
Single Operation The most basic request contains a single anonymous (unnamed) operation. Each operation can have one or more queries within in. For example, the following query has query operation running the queries &amp;ldquo;getTask&amp;rdquo; and &amp;ldquo;getUser&amp;rdquo;:
query { getTask(id: &amp;#34;0x3&amp;#34;) { id title completed } getUser(username: &amp;#34;dgraphlabs&amp;#34;) { username } } Response:</description></item><item><title>Search and Filtering</title><link>/graphql/schema/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/search/</guid><description>The @search directive tells Dgraph what search to build into your GraphQL API.
When a type contains an @search directive, Dgraph constructs a search input type and a query in the GraphQL Query type. For example, if the schema contains
type Post { ... } then Dgraph constructs a queryPost GraphQL query for querying posts. The @search directives in the Post type control how Dgraph builds indexes and what kinds of search it builds into queryPost.</description></item><item><title>Using Auth0</title><link>/graphql/todo-app-tutorial/todo-auth0-jwt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/todo-app-tutorial/todo-auth0-jwt/</guid><description>Let&amp;rsquo;s start by going to our Auth0 dashboard where we can see the application which we have already created and used in our frontend-application.
Now we want to use the JWT that Auth0 generates, but we also need to add custom claims to that token which will be used by our auth rules. So we can use something known as &amp;ldquo;Rules&amp;rdquo; (left sidebar on dashboard page) to add custom claims to a token.</description></item><item><title>Batch Mutations in DQL</title><link>/mutations/batch-mutations/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/batch-mutations/</guid><description>Each mutation may contain multiple RDF triples. For large data uploads many such mutations can be batched in parallel. The command dgraph live does just this; by default batching 1000 RDF lines into a query, while running 100 such queries in parallel.
dgraph live takes as input gzipped N-Quad files (that is triple lists without { set {) and batches mutations for all triples in the input. The tool has documentation of options.</description></item><item><title>Count in DQL</title><link>/query-language/count/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/count/</guid><description>Syntax Examples:
count(predicate) count(uid) The form count(predicate) counts how many predicate edges lead out of a node.
The form count(uid) counts the number of UIDs matched in the enclosing block.
Query Example: The number of films acted in by each actor with Orlando in their name.
Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { me(func: allofterms(name@en, &amp;#34;Orlando&amp;#34;)) @filter(has(actor.film)) { name@en count(actor.film) } } { me(func: allofterms(name@en, &amp;#34;Orlando&amp;#34;)) @filter(has(actor.</description></item><item><title>Encryption at Rest</title><link>/enterprise-features/encryption-at-rest/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/enterprise-features/encryption-at-rest/</guid><description>Note This feature was introduced in v1.1.1. For migrating unencrypted data to a new Dgraph cluster with encryption enabled, you need to export the database and fast data load, preferably using the bulk loader. Encryption at rest refers to the encryption of data that is stored physically in any digital form. It ensures that sensitive data on disks is not readable by any user or application without a valid key that is required for decryption.</description></item><item><title>Loading CSV Data</title><link>/migration/loading-csv-data/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/migration/loading-csv-data/</guid><description>Dgraph mutations are accepted in RDF N-Quad and JSON formats. To load CSV-formatted data into Dgraph, first convert the dataset into one of the accepted formats and then load the resulting dataset into Dgraph. This section demonstrates converting CSV into JSON.
Tip Once you have converted your .csv files to RDF N-Quad/Triple or JSON, you can use Dgraph Live Loader or Dgraph Bulk Loader to import your data. There are many tools available to convert CSV to JSON.</description></item><item><title>Migration Tool</title><link>/migration/migrate-tool/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/migration/migrate-tool/</guid><description>With the Dgraph migration tool you can import SQL data into Dgraph by converting the SQL tables into a schema and RDF file, and then loading the resulting dataset into Dgraph.
Command-line options You can run the Dgraph migrate tool with:
dgraph migrate [flags] Options:
Usage: dgraph migrate [flags] Flags: --db string The database to import -h, --help help for migrate --host string The hostname or IP address of the database server.</description></item><item><title>Single Host Setup</title><link>/deploy/single-host-setup/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/single-host-setup/</guid><description>Run directly on the host You can run Dgraph directly on a single Linux host. As of release v21.03, Dgraph no longer supports installation on Windows or macOS. To run Dgraph on Windows and macOS, use the standalone Docker image.
Run Dgraph zero dgraph zero --my=IPADDR:5080 The --my flag is the connection that Dgraph alphas would dial to talk to zero. So, the port 5080 and the IP address must be visible to all the Dgraph alphas.</description></item><item><title>Tracing</title><link>/deploy/tracing/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/tracing/</guid><description>Dgraph is integrated with OpenCensus to collect distributed traces from the Dgraph cluster.
Trace data is always collected within Dgraph. You can adjust the trace sampling rate for Dgraph queries using the --trace superflag&amp;rsquo;s ratio option when running Dgraph Alpha nodes. By default, --trace ratio is set to 0.01 to trace 1% of queries.
Examining Traces with zPages The most basic way to view traces is with the integrated trace pages.</description></item><item><title>Cached Results</title><link>/graphql/queries/cached-results/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/cached-results/</guid><description>Cached results can be used to serve read-heavy workloads with complex queries to improve performance. When cached results are enabled for a query, the stored results are served if queried within the defined time-to-live (TTL) of the cached query.
When using cached results, Dgraph will add the appropriate HTTP headers so the caching can be done at the browser or content delivery network (CDN) level.
Note Caching refers to external caching at the browser/CDN level.</description></item><item><title>Custom DQL</title><link>/graphql/custom/dql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/custom/dql/</guid><description>Dgraph Query Language (DQL - formerly GraphQL+-) is rapidly evolving, and now includes support for custom logic. You can specify the DQL (aka GraphQL+-) query you want to execute while running a custom GraphQL query, and Dgraph&amp;rsquo;s GraphQL API will execute that for you.
DQL lets you build custom logic that goes beyond what is possible with the current GraphQL CRUD API.
Tip Since v21.03, you can also subscribe to custom DQL queries.</description></item><item><title>GraphQL Error Propagation</title><link>/graphql/api/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/api/errors/</guid><description>Before returning query and mutation results, Dgraph uses the types in the schema to apply GraphQL value completion and error handling. That is, null values for non-nullable fields, e.g. String!, cause error propagation to parent fields.
In short, the GraphQL value completion and error propagation mean the following.
Fields marked as nullable (i.e. without !) can return null in the json response. For fields marked as non-nullable (i.e. with !</description></item><item><title>Lambda Server</title><link>/graphql/lambda/server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/lambda/server/</guid><description>In this article you&amp;rsquo;ll learn how to setup a Dgraph database with a lambda server.
Dgraph Lambda Dgraph Lambda is a serverless platform for running JavaScript on Dgraph and Dgraph Cloud.
You can download the latest version or review the implementation in our open-source repository.
Running with Docker To run a Dgraph Lambda server with Docker:
docker run -it --rm -p 8686:8686 -v /path/to/script.js:/app/script/script.js -e DGRAPH_URL=http://host.docker.internal:8080 dgraph/dgraph-lambda Note host.docker.internal doesn&amp;rsquo;t work on older versions of Docker on Linux.</description></item><item><title>The @generate Directive</title><link>/graphql/schema/generate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/generate/</guid><description>The @generate directive is used to specify which GraphQL APIs are generated for a given type.
Here&amp;rsquo;s the GraphQL definition of the directive
input GenerateQueryParams { get: Boolean query: Boolean password: Boolean aggregate: Boolean } input GenerateMutationParams { add: Boolean update: Boolean delete: Boolean } directive @generate( query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT | INTERFACE The corresponding APIs are generated by setting the Boolean variables inside the @generate directive to true.</description></item><item><title>Using Firebase Authentication</title><link>/graphql/todo-app-tutorial/todo-firebase-jwt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/todo-app-tutorial/todo-firebase-jwt/</guid><description>In this step, we will add Firebase authentication per the sample Todo app with Firebase Authentication.
Create Project Let&amp;rsquo;s start by going to the Firebase website and create a new project (Todo-app).
In the Authentication section, enable Email/Password signin. You can add a custom domain to Authorized domains below according to where you want to deploy your app. By defaut localhost is added to the list.
Now we want to use the JWT that Firebase generates, but we also need to add custom claims to that token which will be used by our authorization rules.</description></item><item><title>A Simple Login System</title><link>/howto/login-system/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/login-system/</guid><description>Note This example is based on part of the transactions in v0.9 blogpost. Error checking has been omitted for brevity. Schema is assumed to be:
// @upsert directive is important to detect conflicts. email: string @index(exact) @upsert . # @index(hash) would also work pass: password . // Create a new transaction. The deferred call to Discard // ensures that server-side resources are cleaned up. txn := client.NewTxn() defer txn.Discard(ctx) // Create and execute a query to looks up an email and checks if the password // matches.</description></item><item><title>Data compression on Disk</title><link>/deploy/data-compression/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/data-compression/</guid><description>Dgraph Alpha lets you configure the compression of data on disk using the --badger superflag&amp;rsquo;s compression option. You can choose between the Snappy and Zstandard compression algorithms, or choose not to compress data on disk.
Note This option replaces the --badger.compression_level and --badger.compression options used in earlier Dgraph versions. The following disk compression settings are available:
Setting Notes none Data on disk will not be compressed. zstd:level Use Zstandard compression, with a compression level specified (1-3).</description></item><item><title>Delete Mutations in DQL</title><link>/mutations/delete/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/delete/</guid><description>A delete mutation, identified by the delete keyword, removes triples from the store.
For example, if the store contained the following:
&amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;name&amp;gt; &amp;#34;Lewis Carrol&amp;#34; &amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;died&amp;gt; &amp;#34;1998&amp;#34; &amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . Then, the following delete mutation deletes the specified erroneous data, and removes it from any indexes:
{ delete { &amp;lt;0xf11168064b01135b&amp;gt; &amp;lt;died&amp;gt; &amp;#34;1998&amp;#34; . } } Wildcard delete In many cases you will need to delete multiple types of data for a predicate.</description></item><item><title>Learner Nodes</title><link>/enterprise-features/learner-nodes/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/enterprise-features/learner-nodes/</guid><description>A Learner node is an enterprise-only feature that allows a user to spin-up a read-only replica instance across the world without paying a latency cost. When enabled, a Dgraph cluster using learner nodes can serve best-effort queries faster.
A &amp;ldquo;learner node&amp;rdquo; can still accept write operations. The node forwards them over to the Alpha group leader and does the writing just like a typical Alpha node. It will just be slower, depending on the latency between the Alpha node and the learner node.</description></item><item><title>Multi-Host Setup</title><link>/deploy/multi-host-setup/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/multi-host-setup/</guid><description>Using Docker Swarm Cluster Setup Using Docker Swarm Note These instructions are for running Dgraph Alpha without TLS config. Instructions for running with TLS refer TLS instructions. Here we&amp;rsquo;ll go through an example of deploying 3 Dgraph Alpha nodes and 1 Zero on three different AWS instances using Docker Swarm with a replication factor of 3.
Make sure you have Docker Machine installed by following instructions. docker-machine --version Create 3 instances on AWS and install Docker Engine on them.</description></item><item><title>Sorting</title><link>/query-language/sorting/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/sorting/</guid><description>Syntax Examples:
q(func: ..., orderasc: predicate) q(func: ..., orderdesc: val(varName)) predicate (orderdesc: predicate) { ... } predicate @filter(...) (orderasc: N) { ... } q(func: ..., orderasc: predicate1, orderdesc: predicate2) Sortable Types: int, float, String, dateTime, default
Results can be sorted in ascending order (orderasc) or descending order (orderdesc) by a predicate or variable.
For sorting on predicates with sortable indices, Dgraph sorts on the values and with the index in parallel and returns whichever result is computed first.</description></item><item><title>Deploying on Dgraph Cloud</title><link>/graphql/todo-app-tutorial/deploy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/todo-app-tutorial/deploy/</guid><description>Let&amp;rsquo;s now deploy our fully functional app on Dgraph Cloud cloud.dgraph.io.
Create a deployment After successfully logging into the site for the first time, your dashboard should look something like this.
Let&amp;rsquo;s go ahead and launch a new deployment.
We named our deployment todo-app-deployment and set the optional subdomain as todo-app, using which the deployment will be accessible. We can choose any subdomain here as long as it is available.</description></item><item><title>Documentation and Comments</title><link>/graphql/schema/documentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/documentation/</guid><description>Schema Documentation Processed by Generated API Dgraph accepts GraphQL documentation comments (e.g. &amp;quot;&amp;quot;&amp;quot; This is a graphql comment &amp;quot;&amp;quot;&amp;quot;), which get passed through to the generated API and thus shown as documentation in GraphQL tools like GraphiQL, GraphQL Playground, Insomnia etc.
Schema Documentation Ignored by Generated API You can also add # ... comments where ever you like. These comments are not passed via the generated API and are not visible in the API docs.</description></item><item><title>Order and Pagination in GraphQL</title><link>/graphql/queries/order-page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/order-page/</guid><description>Every type with fields whose types can be ordered (Int, Float, String, DateTime) gets ordering built into the query and any list fields of that type. Every query and list field gets pagination with first and offset and ordering with order parameter.
The order parameter is not required for pagination.
For example, find the most recent 5 posts.
queryPost(order: { desc: datePublished }, first: 5) { ... } Skip the first five recent posts and then get the next 10.</description></item><item><title>Facet Lists in RDF</title><link>/mutations/facets-in-list-type-with-rdf/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/facets-in-list-type-with-rdf/</guid><description>Schema:
&amp;lt;name&amp;gt;: string @index(exact). &amp;lt;nickname&amp;gt;: [string] . Creating a list with facets in RDF is straightforward.
{ set { _:Julian &amp;lt;name&amp;gt; &amp;#34;Julian&amp;#34; . _:Julian &amp;lt;nickname&amp;gt; &amp;#34;Jay-Jay&amp;#34; (kind=&amp;#34;first&amp;#34;) . _:Julian &amp;lt;nickname&amp;gt; &amp;#34;Jules&amp;#34; (kind=&amp;#34;official&amp;#34;) . _:Julian &amp;lt;nickname&amp;gt; &amp;#34;JB&amp;#34; (kind=&amp;#34;CS-GO&amp;#34;) . } } { q(func: eq(name,&amp;#34;Julian&amp;#34;)){ name nickname @facets } } Result:
{ &amp;#34;data&amp;#34;: { &amp;#34;q&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Julian&amp;#34;, &amp;#34;nickname|kind&amp;#34;: { &amp;#34;0&amp;#34;: &amp;#34;first&amp;#34;, &amp;#34;1&amp;#34;: &amp;#34;official&amp;#34;, &amp;#34;2&amp;#34;: &amp;#34;CS-GO&amp;#34; }, &amp;#34;nickname&amp;#34;: [ &amp;#34;Jay-Jay&amp;#34;, &amp;#34;Jules&amp;#34;, &amp;#34;JB&amp;#34; ] } ] } }</description></item><item><title>License</title><link>/enterprise-features/license/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/enterprise-features/license/</guid><description>Dgraph enterprise features are enabled by default for 30 days in a new cluster. After the trial period of thirty (30) days, the cluster must obtain a license from Dgraph to continue using the enterprise features released in the proprietary code.
Note At the conclusion of your 30-day trial period if a license has not been applied to the cluster, access to the enterprise features will be suspended. The cluster will continue to operate without enterprise features.</description></item><item><title>Load Balancing Queries with NGINX</title><link>/howto/load-balancing-nginx/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/load-balancing-nginx/</guid><description>There might be times when you&amp;rsquo;ll want to set up a load balancer to accomplish goals such as increasing the utilization of your database by sending queries from the app to multiple database server replicas. You can follow these steps to get started with that.
Setting up NGINX load balancer using Docker Compose Download ZIP Download the contents of this gist&amp;rsquo;s ZIP file and extract it to a directory called graph-nginx, as follows:</description></item><item><title>Multiple Query Blocks with DQL</title><link>/query-language/multiple-query-blocks/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/multiple-query-blocks/</guid><description>Inside a single query, multiple query blocks are allowed, and each block can have a name. Multiple query blocks are executed in parallel, and they don&amp;rsquo;t need to be related in any way.
Query Example: &amp;ldquo;All of Angelina Jolie&amp;rsquo;s films, with genres, and Peter Jackson&amp;rsquo;s films since 2008&amp;rdquo;
Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { AngelinaInfo(func:allofterms(name@en, &amp;#34;angelina jolie&amp;#34;)) { name@en actor.film { performance.film { genre { name@en } } } } DirectorInfo(func: eq(name@en, &amp;#34;Peter Jackson&amp;#34;)) { name@en director.</description></item><item><title>Using Kubernetes</title><link>/deploy/kubernetes/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/kubernetes/</guid><description>The following section covers running Dgraph with Kubernetes. We have tested Dgraph with Kubernetes versions 1.14 to 1.16 on GKE and versions 1.14 to 1.17 on EKS.
Note These instructions are for running the Dgraph Alpha service without TLS configuration. To learn how to run Dgraph Alpha with TLS, see TLS Configuration. Install kubectl which is used to deploy and manage applications on kubernetes. Get the Kubernetes cluster up and running on a cloud provider of your choice.</description></item><item><title>@cascade Directive</title><link>/graphql/queries/cascade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/cascade/</guid><description>The @cascade directive can be applied to fields. With the @cascade directive, nodes that don’t have all fields specified in the query are removed. This can be useful in cases where some filter was applied and some nodes might not have all the listed fields.
For example, the query below only returns the authors which have both reputation and posts, where posts have text. Note that @cascade trickles down so if it&amp;rsquo;s applied at the queryAuthor level, it will automatically be applied at the posts level too.</description></item><item><title>Deprecation</title><link>/graphql/schema/deprecated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/deprecated/</guid><description>The @deprecated directive allows you to tag the schema definition of a field or enum value as deprecated with an optional reason.
When you use the @deprecated directive, GraphQL users can deprecate their use of the deprecated field or enum value. Most GraphQL tools and clients will pick up this notification and give you a warning if you try to use a deprecated field.
Example For example, to mark oldField in the schema as deprecated:</description></item><item><title>GraphQL Subscriptions</title><link>/graphql/subscriptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/subscriptions/</guid><description>Subscriptions allow clients to listen to real-time messages from the server. The client connects to the server with a bi-directional communication channel using the WebSocket protocol and sends a subscription query that specifies which event it is interested in. When an event is triggered, the server executes the stored GraphQL query, and the result is sent back to the client using the same communication channel.
The client can unsubscribe by sending a message to the server.</description></item><item><title>Cluster Setup</title><link>/deploy/cluster-setup/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/cluster-setup/</guid><description>Tip For a single server setup, recommended for new users, please see Get Started page. Understanding Dgraph cluster Dgraph is a truly distributed graph database. It shards by predicate and replicates predicates across the cluster, queries can be run on any node and joins are handled over the distributed data. A query is resolved locally for predicates the node stores, and using distributed joins for predicates stored on other nodes.</description></item><item><title>Mutations Using cURL</title><link>/mutations/mutations-using-curl/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/mutations-using-curl/</guid><description>Mutations can be done over HTTP by making a POST request to an Alpha&amp;rsquo;s /mutate endpoint. On the command line this can be done with curl. To commit the mutation, pass the parameter commitNow=true in the URL.
To run a set mutation:
curl -H &amp;#34;Content-Type: application/rdf&amp;#34; -X POST localhost:8080/mutate?commitNow=true -d $&amp;#39; { set { _:alice &amp;lt;name&amp;gt; &amp;#34;Alice&amp;#34; . _:alice &amp;lt;dgraph.type&amp;gt; &amp;#34;Person&amp;#34; . } }&amp;#39; To run a delete mutation:
curl -H &amp;#34;Content-Type: application/rdf&amp;#34; -X POST localhost:8080/mutate?</description></item><item><title>Query Variables in DQL</title><link>/query-language/query-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/query-variables/</guid><description>Syntax Examples:
varName as q(func: ...) { ... } varName as var(func: ...) { ... } varName as predicate { ... } varName as predicate @filter(...) { ... } Types : uid
Nodes (UIDs) matched at one place in a query can be stored in a variable and used elsewhere. Query variables can be used in other query blocks or in a child node of the defining block.
Query variables do not affect the semantics of the query at the point of definition.</description></item><item><title>Upserts</title><link>/howto/upserts/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/upserts/</guid><description>Upsert-style operations are operations where:
A node is searched for, and then Depending on if it is found or not, either: Updating some of its attributes, or Creating a new node with those attributes. The upsert has to be an atomic operation such that either a new node is created, or an existing node is modified. It&amp;rsquo;s not allowed that two concurrent upserts both create a new node.
There are many examples where upserts are useful.</description></item><item><title>@skip and @include Directives in GraphQL</title><link>/graphql/queries/skip-include/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/queries/skip-include/</guid><description>@skip and @include directives can be applied to query fields. They allow you to skip or include a field based on the value of the if argument that is passed to the directive.
@skip In the query below, we fetch posts and decide whether to fetch the title for them or not based on the skipTitle GraphQL variable.
GraphQL query
query ($skipTitle: Boolean!) { queryPost { id title @skip(if: $skipTitle) text } } GraphQL variables</description></item><item><title>Dgraph Schema Fragment</title><link>/graphql/schema/dgraph-schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/schema/dgraph-schema/</guid><description>While editing your schema, you might find it useful to include this GraphQL schema fragment. It sets up the definitions of the directives, etc. (like @search) that you&amp;rsquo;ll use in your schema. If your editor is GraphQL aware, it may give you errors if you don&amp;rsquo;t have this available and context sensitive help if you do.
Don&amp;rsquo;t include it in your input schema to Dgraph - use your editing environment to set it up as an import.</description></item><item><title>Cluster Checklist</title><link>/deploy/cluster-checklist/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/cluster-checklist/</guid><description>In setting up a cluster be sure the check the following.
Is at least one Dgraph Zero node running? Is each Dgraph Alpha instance in the cluster set up correctly? Will each Dgraph Alpha instance be accessible to all peers on 7080 (+ any port offset)? Does each instance have a unique ID on startup? Has --bindall=true been set for networked communication? See the Production Checklist docs for more info.</description></item><item><title>JSON Mutation Format</title><link>/mutations/json-mutation-format/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/json-mutation-format/</guid><description>Mutations can also be specified using JSON objects. This can allow mutations to be expressed in a more natural way. It also eliminates the need for apps to have custom serialization code, since most languages already have a JSON marshaling library.
When Dgraph receives a mutation as a JSON object, it first converts it into an internal edge format that is then processed into Dgraph.
JSON -&amp;gt; Edges -&amp;gt; Posting list RDF -&amp;gt; Edges -&amp;gt; Posting list</description></item><item><title>Run Jepsen Tests</title><link>/howto/jepsen-tests/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/howto/jepsen-tests/</guid><description> Clone the Jepsen repo at https://github.com/jepsen-io/jepsen. git clone git@github.com:jepsen-io/jepsen.git Run the following command to setup the instances from the repo. cd docker &amp;amp;&amp;amp; ./up.sh This should start 5 Jepsen nodes in docker containers.
Now ssh into jepsen-control container and run the tests. docker exec -it jepsen-control bash root@control:/jepsen# cd dgraph root@control:/jepsen/dgraph# lein run test -w upsert # Specify a --package-url root@control:/jepsen/dgraph# lein run test --force-download --package-url https://github.com/dgraph-io/dgraph/releases/download/nightly/dgraph-linux-amd64.tar.gz -w upsert</description></item><item><title>Value Variables in DQL</title><link>/query-language/value-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/value-variables/</guid><description>Value variables store scalar values in DQL. Value variables are a map from the UIDs of the enclosing block to the corresponding values.
The following are examples of value variables:
varName as scalarPredicate varName as count(predicate) varName as avg(...) varName as math(...) These variables map to the following types: int, float, String, dateTime, default, geo, bool
It only makes sense to use the values from a value variable in a context that matches the same UIDs - if used in a block matching different UIDs the value variable is undefined.</description></item><item><title>Aggregation in DQL</title><link>/query-language/aggregation/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/aggregation/</guid><description>Syntax Example: AG(val(varName))
For AG replaced with
min : select the minimum value in the value variable varName max : select the maximum value sum : sum all values in value variable varName avg : calculate the average of values in varName Schema Types:
Aggregation Schema Types min / max int, float, string, dateTime, default sum / avg int, float Aggregation can only be applied to value variables. An index is not required (the values have already been found and stored in the value variable mapping).</description></item><item><title>Migrate from Dgraph v1.0</title><link>/migration/migrate-dgraph-1-1/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/migration/migrate-dgraph-1-1/</guid><description>This document summarizes major changes in Dgraph database that you should be aware of as you migrate your data and client applications from Dgraph v1.0 to newer Dgraph versions.
Schema types: scalar uid and list [uid] The semantics of predicates of type uid has changed since Dgraph v1.0. In Dgraph v1.0 all uid predicates implied a one-to-many relationship, but now you can express a one-to-one relationship or a one-to-many relationship. The following syntax example demonstrates both types of relationships:</description></item><item><title>Production Checklist</title><link>/deploy/production-checklist/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/production-checklist/</guid><description>This guide describes important setup recommendations for a production-ready Dgraph cluster.
Note In this guide, a node refers to a Dgraph instance unless specified otherwise. A Dgraph cluster is comprised of multiple Dgraph instances (aka nodes) connected together to form a single distributed database. A Dgraph instance is either a Dgraph Zero or Dgraph Alpha, each of which serves a different role in the cluster.
Cluster Requirements A minimum of one Dgraph Zero and one Dgraph Alpha is needed for a working cluster.</description></item><item><title>Upsert Blocks in DQL</title><link>/mutations/upsert-block/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/upsert-block/</guid><description>Upsert blocks allow you to perform both queries and mutations in a single request. The upsert block contains one query block and one or more than one mutation blocks. Variables defined in the query block can be used in the mutation blocks using the uid and val function.
In general, the structure of the upsert block is as follows:
upsert { query &amp;lt;query block&amp;gt; [fragment &amp;lt;fragment block&amp;gt;] mutation &amp;lt;mutation block 1&amp;gt; [mutation &amp;lt;mutation block 2&amp;gt;] .</description></item><item><title>Index of Directives in GraphQL</title><link>/graphql/directives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/directives/</guid><description>The list of all directives supported by Dgraph.
@auth @auth allows you to define how to apply authorization rules on the queries/mutation for a type.
Reference: Auth directive
@cascade @cascade allows you to filter out certain nodes within a query.
Reference: Cascade
@custom @custom directive is used to define custom queries, mutations and fields.
Reference: Custom directive
@deprecated The @deprecated directive lets you mark the schema definition of a field or enum value as deprecated, and also lets you provide an optional reason for the deprecation.</description></item><item><title>Lambda Webhooks Example</title><link>/howto/lambda-webhooks-example/</link><pubDate>Sun, 10 Sep 2017 22:25:17 +1100</pubDate><guid>/howto/lambda-webhooks-example/</guid><description>It is a common need to populate a &amp;ldquo;Created At&amp;rdquo; date whenever a new data is created. Using Lambda Webhooks, the population of this field can be offloaded from the clients to a Dgraph Lambda. Lambda Webhooks are special kind of lambdas that are automatically invoked whenever data belonging to a GraphQL type is added, modified, or deleted.
Steps to run this example are as follows.
The GraphQL Schema type Author @lambdaOnMutate(add: true, update: true, delete: true) { id: ID!</description></item><item><title>Bulk Loader</title><link>/deploy/fast-data-loading/bulk-loader/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/fast-data-loading/bulk-loader/</guid><description>Dgraph Bulk Loader serves a similar purpose to the Dgraph Live Loader, but can only be used to load data into a new cluster. It cannot be run on an existing Dgraph cluster. Dgraph Bulk Loader is considerably faster than the Dgraph Live Loader and is the recommended way to perform the initial import of large datasets into Dgraph.
Only one or more Dgraph Zeros should be running for bulk loading.</description></item><item><title>Conditional Upsert</title><link>/mutations/conditional-upsert/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/conditional-upsert/</guid><description>The upsert block also allows specifying conditional mutation blocks using an @if directive. The mutation is executed only when the specified condition is true. If the condition is false, the mutation is silently ignored. The general structure of Conditional Upsert looks like as follows:
upsert { query &amp;lt;query block&amp;gt; [fragment &amp;lt;fragment block&amp;gt;] mutation [@if(&amp;lt;condition&amp;gt;)] &amp;lt;mutation block 1&amp;gt; [mutation [@if(&amp;lt;condition&amp;gt;)] &amp;lt;mutation block 2&amp;gt;] ... } The @if directive accepts a condition on variables defined in the query block and can be connected using AND, OR and NOT.</description></item><item><title>Live Loader</title><link>/deploy/fast-data-loading/live-loader/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/deploy/fast-data-loading/live-loader/</guid><description>Dgraph Live Loader (run with dgraph live) is a small helper program which reads RDF N-Quads from a gzipped file, batches them up, creates mutations (using the go client) and shoots off to Dgraph.
Dgraph Live Loader correctly handles assigning unique IDs to blank nodes across multiple files, and can optionally persist them to disk to save memory, in case the loader was re-run.
Note Dgraph Live Loader can optionally write the xid-&amp;gt;uid mapping to a directory specified using the --xidmap flag, which can reused given that live loader completed successfully in the previous run.</description></item><item><title>Math on Value Variables</title><link>/query-language/math-on-value-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/math-on-value-variables/</guid><description>Value variables can be combined using mathematical functions. For example, this could be used to associate a score which is then used to order or perform other operations, such as might be used in building news feeds, simple recommendation systems, and so on.
Math statements must be enclosed within math( &amp;lt;exp&amp;gt; ) and must be stored to a value variable.
The supported operators are as follows:
Operators Types accepted What it does + - * / % int, float performs the corresponding operation min max All types except geo, bool (binary functions) selects the min/max value among the two &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == !</description></item><item><title>Administrative API on GraphQL</title><link>/graphql/admin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/admin/</guid><description>This article presents the Admin API and explains how to run a Dgraph database with GraphQL.
Running Dgraph with GraphQL The simplest way to start with Dgraph GraphQL is to run the all-in-one Docker image.
docker run -it -p 8080:8080 dgraph/standalone:master That brings up GraphQL at localhost:8080/graphql and localhost:8080/admin, but is intended for quickstart and doesn&amp;rsquo;t persist data.
Advanced options Once you&amp;rsquo;ve tried out Dgraph GraphQL, you&amp;rsquo;ll need to move past the dgraph/standalone and run and deploy Dgraph instances.</description></item><item><title>GroupBy</title><link>/query-language/groupby/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/groupby/</guid><description>Syntax Examples:
q(func: ...) @groupby(predicate) { min(...) } predicate @groupby(pred) { count(uid) } A groupby query aggregates query results given a set of properties on which to group elements. For example, a query containing the block friend @groupby(age) { count(uid) }, finds all nodes reachable along the friend edge, partitions these into groups based on age, then counts how many nodes are in each group. The returned result is the grouped edges and the aggregations.</description></item><item><title>Reverse Edges</title><link>/mutations/reverse-edges/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/mutations/reverse-edges/</guid><description>Any outgoing edge in Dgraph can be reversed using the @reverse directive in the schema and be queried using tilde as the prefix of the edge name. e.g. &amp;lt;~myEdge&amp;gt;.
Dgraph serializes directed graphs. This means that all properties always point from an entity to another entity or value in a single direction. S P -&amp;gt; O.
Reverse edges are automatically generated edges and are not part of your dataset. This means that you cannot run mutations directly on the reverse edges.</description></item><item><title>Dgraph Compared to Other Databases</title><link>/migration/dgraph-compared-to-other-databases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/migration/dgraph-compared-to-other-databases/</guid><description>This guide compares Dgraph with other popular graph databases and datastores, to help you decide if Dgraph suits your needs. For more on how Dgraph compares to other cloud-based graph databases, see (https://dgraph.io/comparison).
Batch-based Batch based graph processing frameworks provide a very high throughput to do periodic processing of data. This is useful to convert graph data into a shape readily usable by other systems to then serve the data to end users.</description></item><item><title>GraphQL on Existing Dgraph</title><link>/graphql/dgraph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/dgraph/</guid><description>How to use GraphQL on an existing Dgraph instance If you have an existing Dgraph instance and want to also expose GraphQL, you need to add a GraphQL schema that maps to your Dgraph schema. You don&amp;rsquo;t need to expose your entire Dgraph schema as GraphQL, but do note that adding a GraphQL schema can alter the Dgraph schema.
Dgraph&amp;rsquo;s native DQL syntax allows type and edge names that aren&amp;rsquo;t valid in GraphQL; so, you&amp;rsquo;ll often need to expose valid GraphQL names.</description></item><item><title>Expand Predicates in DQL</title><link>/query-language/expand-predicates/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/expand-predicates/</guid><description>The expand() function can be used to expand the predicates out of a node. To use expand(), the type system is required. Refer to the section on the type system to check how to set the types nodes. The rest of this section assumes familiarity with that section.
There are two ways to use the expand function:
1. Expand predicates by type Types can be passed to expand() to expand all the predicates of the specified type.</description></item><item><title>Apollo Federation</title><link>/graphql/federation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/graphql/federation/</guid><description>Dgraph supports Apollo federation starting in release version 21.03. This lets you create a gateway GraphQL service that includes the Dgraph GraphQL API and other GraphQL services.
Support for Apollo federation directives The current implementation supports the following five directives: @key, @extends, @external, @provides, and @requires.
@key directive This directive takes one field argument inside it: the @key field. There are few limitations on how to use @key directives:
Users can define the @key directive only once for a type Support for multiple key fields is not currently available.</description></item><item><title>Cascade Directive</title><link>/query-language/cascade-directive/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/cascade-directive/</guid><description>With the @cascade directive, nodes that don&amp;rsquo;t have all predicates specified in the query are removed. This can be useful in cases where some filter was applied or if nodes might not have all listed predicates.
Query Example: Harry Potter movies, with each actor and characters played. With @cascade, any character not played by an actor called Warwick is removed, as is any Harry Potter movie without any actors called Warwick.</description></item><item><title>@normalize Directive</title><link>/query-language/normalize-directive/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/normalize-directive/</guid><description>With the @normalize directive, only aliased predicates are returned and the result is flattened to remove nesting.
Query Example: Film name, country and first two actors (by UID order) of every Steven Spielberg movie, without initial_release_date because no alias is given and flattened by @normalize Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { director(func:allofterms(name@en, &amp;#34;steven spielberg&amp;#34;)) @normalize { director: name@en director.film { film: name@en initial_release_date starring(first: 2) { performance.</description></item><item><title>@ignorereflex Directive</title><link>/query-language/ignorereflex-directive/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/ignorereflex-directive/</guid><description>The @ignorereflex directive forces the removal of child nodes that are reachable from themselves as a parent, through any path in the query result
Query Example: All the co-actors of Rutger Hauer. Without @ignorereflex, the result would also include Rutger Hauer for every movie.
Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { coactors(func: eq(name@en, &amp;#34;Rutger Hauer&amp;#34;)) @ignorereflex { actor.film { performance.film { starring { performance.actor { name@en } } } } } } { coactors(func: eq(name@en, &amp;#34;Rutger Hauer&amp;#34;)) @ignorereflex { actor.</description></item><item><title>Data Decryption</title><link>/deploy/decrypt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/deploy/decrypt/</guid><description>You might need to decrypt data from an encrypted Dgraph cluster for a variety of reasons, including:
Migration of data from an encrypted cluster to a non-encrypted cluster Changing your data or schema by directly editing an RDF file or schema file To support these scenarios, Dgraph includes a decrypt command that decrypts encrypted RDF and schema files. To learn how to export RDF and schema files from Dgraph, see: Dgraph Administration: Export database.</description></item><item><title>Debug</title><link>/query-language/debug/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/debug/</guid><description>For the purposes of debugging, you can attach a query parameter debug=true to a query. Attaching this parameter lets you retrieve the uid attribute for all the entities along with the server_latency and start_ts information under the extensions key of the response.
parsing_ns: Latency in nanoseconds to parse the query. processing_ns: Latency in nanoseconds to process the query. encoding_ns: Latency in nanoseconds to encode the JSON response. start_ts: The logical start timestamp of the transaction.</description></item><item><title>Schemas in DQL</title><link>/query-language/schema/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/schema/</guid><description>For each predicate, the Dgraph Query Language (DQL) schema specifies the target&amp;rsquo;s type. If a predicate p has type T, then for all subject-predicate-object triples s p o the object o is of schema type T.
On mutations, scalar types are checked and an error thrown if the value cannot be converted to the schema type.
On query, value results are returned according to the schema type of the predicate.</description></item><item><title>Dgraph CLI Reference</title><link>/deploy/cli-command-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/deploy/cli-command-reference/</guid><description>You can use the Dgraph command-line interface (CLI) to deploy and manage Dgraph. You use it in self-managed deployment scenarios; such as running Dgraph on on-premises servers hosted on your physical infrastructure, or running Dgraph in the cloud on your AWS, GCP, or Azure infrastructure.
Dgraph has a root command used throughout its CLI: dgraph. The dgraph command is supported by multiple subcommands (such as alpha or update), some of which are also supported by their own subcommands.</description></item><item><title>DQL Type System</title><link>/query-language/type-system/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/type-system/</guid><description>Dgraph supports a type system that can be used to categorize nodes and query them based on their type. The type system is also used during expand queries.
Type definition Types are defined using a GraphQL-like syntax. For example:
type Student { name dob home_address year friends } Note You can&amp;rsquo;t define type names starting with dgraph., it is reserved as the namespace for Dgraph&amp;rsquo;s internal types/predicates. For example, defining dgraph.</description></item><item><title>Troubleshooting</title><link>/deploy/troubleshooting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/deploy/troubleshooting/</guid><description>This page provides tips on how to troubleshoot issues with running Dgraph.
Running out of memory (OOM) When you bulk load or backup your data, Dgraph can consume more memory than usual due to a high volume of writes. This can cause OOM crashes.
You can take the following steps to help avoid OOM crashes:
Increase the amount of memory available: If you run Dgraph with insufficient memory, that can result in OOM crashes.</description></item><item><title>Facets and Edge Attributes in DQL</title><link>/query-language/facets/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/facets/</guid><description>Dgraph supports facets &amp;mdash; key value pairs on edges &amp;mdash; as an extension to RDF triples. That is, facets add properties to edges, rather than to nodes. For example, a friend edge between two nodes may have a Boolean property of close friendship. Facets can also be used as weights for edges.
Though you may find yourself leaning towards facets many times, they should not be misused. It wouldn&amp;rsquo;t be correct modeling to give the friend edge a facet date_of_birth.</description></item><item><title>Shortest Path Queries</title><link>/query-language/kshortest-path-quries/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/kshortest-path-quries/</guid><description>The shortest path between a source (from) node and destination (to) node can be found using the keyword shortest for the query block name. It requires the source node UID, destination node UID and the predicates (at least one) that have to be considered for traversal. A shortest query block returns the shortest path under _path_ in the query response. The path can also be stored in a variable which is used in other query blocks.</description></item><item><title>Recurse Query</title><link>/query-language/recurse-query/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/recurse-query/</guid><description>Recurse queries let you traverse a set of predicates (with filter, facets, etc.) until we reach all leaf nodes or we reach the maximum depth which is specified by the depth parameter.
To get 10 movies from a genre that has more than 30000 films and then get two actors for those movies we&amp;rsquo;d do something as follows: Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { me(func: gt(count(~genre), 30000), first: 1) @recurse(depth: 5, loop: true) { name@en ~genre (first:10) @filter(gt(count(starring), 2)) starring (first: 2) performance.</description></item><item><title>Fragments</title><link>/query-language/fragments/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/fragments/</guid><description>The fragment keyword lets you define new fragments that can be referenced in a query, per the Fragments section of the GraphQL specification. Fragments allow for the reuse of common repeated selections of fields, reducing duplicated text in the DQL documents. Fragments can be nested inside fragments, but no cycles are allowed in such cases. For example:
curl -H &amp;#34;Content-Type: application/dql&amp;#34; localhost:8080/query -XPOST -d $&amp;#39; query { debug(func: uid(1)) { name@en .</description></item><item><title>GraphQL Variables</title><link>/query-language/graphql-variables/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/graphql-variables/</guid><description>Syntax Examples (using default values):
query title($name: string = &amp;quot;Bauman&amp;quot;) { ... } query title($age: int = &amp;quot;95&amp;quot;) { ... } query title($uids: string = &amp;quot;0x1&amp;quot;) { ... } query title($uids: string = &amp;quot;[0x1, 0x2, 0x3]&amp;quot;) { ... }. The value of the variable is a quoted array. Variables can be defined and used in queries which helps in query reuse and avoids costly string building in clients at runtime by passing a separate variable map.</description></item><item><title>Indexing with Custom Tokenizers</title><link>/query-language/indexing-custom-tokenizers/</link><pubDate>Mon, 20 Mar 2017 22:25:17 +1100</pubDate><guid>/query-language/indexing-custom-tokenizers/</guid><description>Dgraph comes with a large toolkit of builtin indexes, but sometimes for niche use cases they&amp;rsquo;re not always enough.
Dgraph allows you to implement custom tokenizers via a plugin system in order to fill the gaps.
Caveats The plugin system uses Go&amp;rsquo;s pkg/plugin. This brings some restrictions to how plugins can be used.
Plugins must be written in Go.
As of Go 1.9, pkg/plugin only works on Linux. Therefore, plugins will only work on Dgraph instances deployed in a Linux environment.</description></item><item><title>FAQ</title><link>/faq/</link><pubDate>Mon, 20 Mar 2017 19:35:35 +1100</pubDate><guid>/faq/</guid><description>General What is Dgraph? Dgraph is a distributed, low-latency, high throughput graph database, written in Go. It puts a lot of emphasis on good design, concurrency and minimizing network calls required to execute a query in a distributed environment.
Why build Dgraph? We think graph databases are currently second class citizens. They are not considered mature enough to be run as the sole database, and get run alongside other SQL/NoSQL databases.</description></item><item><title>Dgraph Database Overview</title><link>/dgraph-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/dgraph-overview/</guid><description>Dgraph is a horizontally scalable and distributed GraphQL database with a graph backend. Dgraph is built for the heavy transactional workloads required to power modern apps and websites, but it isn’t limited to only these types of applications. Whether you are looking to power the backend of your app, create elastic search for your website, or build a new database purely for data analysis, Dgraph is up to the task. In fact, it is in production today in the following real-world scenarios:</description></item><item><title>Dgraph Releases</title><link>/releases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/releases/</guid><description>The latest Dgraph release is the v21.12 series.
Dgraph releases starting with v20.03 follow calendar versioning. To learn more about our switch from semantic to calendar versioning, and why v2-v19 don&amp;rsquo;t exist as a result of this switch, see our Blog post on the switch to calendar versioning.
To learn about the latest releases and other important announcements, watch the Announce category on Discuss.
Release series Dgraph Release Series Current Release Supported?</description></item><item><title>Get Started - Quickstart Guide</title><link>/get-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/get-started/</guid><description>Note This is a quick start guide. You can find the getting started tutorial series here. Dgraph Designed from the ground up to be run in production, Dgraph is the native GraphQL database with a graph backend. It is open-source, scalable, distributed, highly available and lightning fast.
Dgraph cluster consists of different nodes (Zero, Alpha &amp;amp; Ratel), and each node serves a different purpose.
Dgraph Zero controls the Dgraph cluster, assigns servers to a group, and re-balances data between server groups.</description></item><item><title>Get Started with Dgraph - Advanced Text Search on Social Graphs</title><link>/tutorial-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-6/</guid><description>Welcome to the sixth tutorial of getting started with Dgraph.
In the previous tutorial, we learned about building social graphs in Dgraph, by modeling tweets as an example. We queried the tweets using the hash and exact indices, and implemented a keyword-based search to find your favorite tweets using the term index and its functions.
In this tutorial, we&amp;rsquo;ll continue from where we left off and learn about advanced text search features in Dgraph.</description></item><item><title>Get Started with Dgraph - Basic Operations</title><link>/tutorial-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-2/</guid><description>Welcome to the second tutorial of getting started with Dgraph.
In the previous tutorial of getting started, we learned some of the basics of Dgraph. Including how to run the database, add new nodes and predicates, and query them back.
In this tutorial, we&amp;rsquo;ll build the above Graph and learn more about operations using the UID (Universal Identifier) of the nodes. Specifically, we&amp;rsquo;ll learn about:
Querying and updating nodes, deleting predicates using their UIDs.</description></item><item><title>Get Started with Dgraph - Basic Types and Operations</title><link>/tutorial-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-3/</guid><description>Welcome to the third tutorial of getting started with Dgraph.
In the previous tutorial, we learned about CRUD operations using UIDs. We also learned about traversals and recursive traversals.
In this tutorial, we&amp;rsquo;ll learn about Dgraph&amp;rsquo;s basic types and how to query for them. Specifically, we&amp;rsquo;ll learn about:
Basic data types in Dgraph. Querying for predicate values. Indexing. Filtering nodes. Reverse traversing. Check out the accompanying video:
Let&amp;rsquo;s start by building the graph of a simple blog application.</description></item><item><title>Get Started with Dgraph - Fuzzy Search on Social Graphs</title><link>/tutorial-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-7/</guid><description>Welcome to the seventh tutorial of getting started with Dgraph.
In the previous tutorial, we learned about building advanced text searches on social graphs in Dgraph, by modeling tweets as an example. We queried the tweets using the fulltext and trigram indices and implemented full-text and regular expression search on the tweets.
In this tutorial, we&amp;rsquo;ll continue exploring Dgraph&amp;rsquo;s string querying capabilities using the twitter model from the fifth and the sixth tutorials.</description></item><item><title>Get Started with Dgraph - Introduction</title><link>/tutorial-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-1/</guid><description>Welcome to getting started with Dgraph.
Dgraph is an open-source, transactional, distributed, native Graph Database. Here is the first tutorial of the get started series on using Dgraph.
In this tutorial, we&amp;rsquo;ll learn how to build the following graph on Dgraph,
In the process, we&amp;rsquo;ll learn about:
Running Dgraph using the dgraph/standalone docker image. Running the following basic operations using Dgraph&amp;rsquo;s UI Ratel, Creating a node. Creating an edge between two nodes.</description></item><item><title>Get Started with Dgraph - Multi-language strings</title><link>/tutorial-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-4/</guid><description>Welcome to the fourth tutorial of getting started with Dgraph.
In the previous tutorial, we learned about Datatypes, Indexing, Filtering, and Reverse traversals in Dgraph.
In this tutorial, we&amp;rsquo;ll learn about using multi-language strings and operations on them using the language tags.
You can see the accompanying video below.
Strings and languages Strings values in Dgraph are of UTF-8 format. Dgraph also supports values for string predicate types in multiple languages.</description></item><item><title>Get Started with Dgraph - Native Geolocation Features</title><link>/tutorial-8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-8/</guid><description>Welcome to the eight tutorial of getting started with Dgraph.
In the previous tutorial, we learned about building a twitter-like user-search feature using Dgraph&amp;rsquo;s fuzzy search.
In this tutorial, we&amp;rsquo;ll build a graph of tourist locations around San Francisco and help our Zoologist friend, Mary, and her team in their mission to conserve birds using Dgraph&amp;rsquo;s geolocation capabilities.
You might have used Google to find the restaurants near you or to find the shopping centers within a mile of your current location.</description></item><item><title>Get Started with Dgraph - String Indices and Modeling Tweet Graph</title><link>/tutorial-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial-5/</guid><description>Welcome to the fifth tutorial of getting started with Dgraph.
In the previous tutorial, we learned about using multi-language strings and operations on them using language tags.
In this tutorial, we&amp;rsquo;ll model tweets in Dgraph and, using it, we&amp;rsquo;ll learn more about string indices in Dgraph.
We&amp;rsquo;ll specifically learn about:
Modeling tweets in Dgraph. Using String indices in Dgraph Querying twitter users using the hash index. Comparing strings using the exact index.</description></item><item><title>Tips and Tricks with DQL</title><link>/tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tips/</guid><description>Get Sample Data Use the has function to get some sample nodes.
Query Go Java Python JavaScript (gRPC) JavaScript (HTTP) Curl Run Editing query... { result(func: has(director.film), first: 10) { uid expand(_all_) } } { result(func: has(director.film), first: 10) { uid expand(_all_) } } curl localhost:8080/query -XPOST -d 'blahblah' | python -m json.tool | less package main import ( "context" "flag" "fmt" "log" "github.com/dgraph-io/dgo" "github.com/dgraph-io/dgo/protos/api" "google.golang.org/grpc" ) var ( dgraph = flag.</description></item><item><title>Tutorials - Get Started with Dgraph series</title><link>/tutorials/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorials/</guid><description>Note This is a tutorial series on getting started with Dgraph. You can find a single page quickstart guide here. Welcome to Dgraph. Here are a series of tutorials for getting started:
1 - Introduction Run dgraph and learn about nodes and edges, as well as basic queries and mutations. 2 - Basic Operations Learn about UID operations, updating nodes, and traversals. 3 - Basic Types and Operations on them Learn about data types, indexing, filtering, and reverse traversals.</description></item></channel></rss>